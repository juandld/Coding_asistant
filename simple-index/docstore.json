{"docstore/metadata": {"4007e36c-fc31-4ee2-af62-4e02d815b214": {"doc_hash": "ca273ec6b8b27307dfa53ab2103334be5f3a7492d50391e781731fc64dfeffff"}, "a284a99e-4d80-444f-9aff-a2cf11c03638": {"doc_hash": "632dd5ec615ce8df38a4df22db90006441f1ec1ce3441cfaef468b096f65cf02"}, "99eba38d-9650-476b-9d95-4c2ea3e10aa1": {"doc_hash": "03008711fbccefdf5db1d7c70091a0ae6f5385d1e340c1c0f86878a1afff8dc7"}, "05204e97-d059-4dbe-96b6-3b4ff7b214ce": {"doc_hash": "aa96c50a0903bebf19886a0ee7cfa74fd4661f36f35058d34fa3d4a1a0d4e017"}, "9f1b006b-e9fd-4c13-9850-0eaa1ed8c649": {"doc_hash": "8d9495833c8b840eea18955a3d1732888db512da4337084c1a965b4de3514719"}, "95979001-4675-4e7b-9844-cf8470b541fc": {"doc_hash": "00d1e3d05ab0d99587f37b902ece7d51920a86c0811a455e06d3c6d588bad249"}, "d051101a-0d69-43f7-acdc-c836532b57ac": {"doc_hash": "7cbc5d77f3ecd069121fbee8a4a6a17eb963e4b577b9a53bda7efb1864810cd7"}, "d00bf1fb-997a-4bcf-87f5-4c068f776570": {"doc_hash": "d4d9e05a32239331912c699f30754e9cccc67194ed76306ee0238355bc75802f"}, "9203ee87-ae02-423b-a064-5c8726add720": {"doc_hash": "c1d7e63dd21a4a388335d036d27f5e7fa27d0ff719235825040a45b3ee44ada7"}, "54278afd-3d98-4fd6-8d2e-fd10fdc4e124": {"doc_hash": "f43044f98475665b2fcd6ee90dc00add33bf17fb807819c8df94c7e170ee2256"}, "6f854dd2-b330-4761-ac10-458b1fee9c95": {"doc_hash": "59e1623aebd38b6f89ccc6acb8a6eccbfbb7ff5d264072b632c4cf5839331044"}, "054ccfb2-bafe-4095-9be9-ee8d163fee62": {"doc_hash": "bf84ba0e8cfc60e0edd31f264572b6361a178a712aa76a48f0a92f154a63851e"}, "cac9584d-af43-4f7e-b3d0-e14a86bfc6c5": {"doc_hash": "604fb6b78ee3e96bef053efc0a9f2370afed58cbff96935417cc4dfaef6ca45b"}, "02125823-1c45-4bcd-8e3e-40d97d648c25": {"doc_hash": "840f55d4328820f54af8d287c4baeae528d6a51998292dace059217ca35e31bb"}, "4b768329-f376-4503-973a-4c05d58fc24b": {"doc_hash": "0764b30f2904c778a7afca2273c1dcf46ea81c1a8530af39b95173b0f91113a5"}, "364739d8-0008-4e62-8007-786597604a01": {"doc_hash": "04db49cb6c1b30527a26766bd67cde1e258ea4cd9720648c36a1b92bdbabe5ad"}, "024e6ac1-6875-4983-86bf-5d767369e120": {"doc_hash": "d684b8f4eeca2a1eb8db51fe08eb5ddb25b881766e36519a8386fadee2ea5e42"}, "dbe78fc6-4af8-431d-8135-44a22dee0c8b": {"doc_hash": "0ca72880a452943e87cb07e4a0b30653db978ed86469d334d7572a3e21ea7128"}, "4c4045d3-0b09-4e6a-9f2d-3b20a8e53411": {"doc_hash": "98cd50ededb453b24514a8d200ffaeb17432374838cef9935a4cf553890a355d"}, "91afda7e-244b-43a4-9bc0-e54bc7e5b30f": {"doc_hash": "21d1a3e449c609955ed86ace535176c0369dc1c5fb9c6344c99770c1f3aa2371"}, "47d210da-f877-402b-af3f-0a2b5c8dd057": {"doc_hash": "69f45c1d2e45a74b47a1db77f2af1c1005a64dfd60baed53adb3920126689191"}, "ce4218e0-7d23-45e1-a8a1-1a566716a547": {"doc_hash": "b70fadd093be7a03e1fa84bcbfb8dcfd4b8e412ec67aeaa5276b56cc9e5e2f11"}, "ad537e54-06f5-4c57-87b6-d73e1c967e57": {"doc_hash": "338e5a292e0b113783c59c3e2ab7863ac1008ce32c680938615cfbc5abd20873"}, "990479c0-082d-4190-b77b-2dfe03fa148f": {"doc_hash": "9c71b2be583f726528332f6e785970ae3f857ef51aef60a6255a08176900f9fa"}, "08a70bf9-6a2e-43ca-824b-7fb2af0639d4": {"doc_hash": "59e5b39a8f9acb629ab563ad67ebc23ce2b56e96152ba5346544c07faf41a3c3"}, "d883be15-009e-4f33-9e07-66aa9849540f": {"doc_hash": "28f7584296e007d21938c7e7c32140788260e1e1ece77b784caff2f1063abb00"}, "83cf7b29-9651-4de8-9a4d-71dfef9c7119": {"doc_hash": "e4e112cf8a9afc9b22386904b1d2f5aacdc9910222b889a3f18db308399e3a93"}, "8240a462-a53d-4034-80c1-86da524f7604": {"doc_hash": "f537d0dcd99ebbcdf66aa17d9198174ae2d04a8010c1977bf36b4d7874ef367e"}, "e0db49bf-2954-4a45-9955-0b8209668640": {"doc_hash": "9a9712b4c63846fdd7829ea4d1d0facf21d0ca314ef33059c609264c363741ae"}, "1131f8cd-14c1-4fdf-9982-003d436a8fd0": {"doc_hash": "a66ba03c2050d9c96183af4b60e4719306f6b0dfacf0f129f87d03940f151f80"}, "ba251ef5-e8cb-40ef-835f-24984c9ef3ed": {"doc_hash": "a9e81a6470c7a42a6a7d44c59553785ae0a4f040ef17c16423dd89e41f44ed13"}, "51fcdaa3-85f2-49c0-8964-2b74e5ebaf61": {"doc_hash": "24ee92b5d88635bfdaa83683867b45e4dd6bf114953ef4b0ef20432471d00388"}, "86af7db9-24a4-4bdc-80a4-b1e36f58bf9b": {"doc_hash": "6e7747f19cd6483636988033453a9c7207ac165cbe75813f3e2eda7c36d523c8"}, "17c0a953-848a-4041-90ea-e03c8605e063": {"doc_hash": "0456468909fa48748ae951861303bafb1cd89bf19938f05a97fd4fae38712f15"}, "4c2731f7-d73c-4ffd-8884-444d4e65c24f": {"doc_hash": "c9f59ecbc8da33af4c617c5e7cd60625146df16420bca9c9aa2237706414a6b6"}, "74e019d6-bb00-4f30-891b-54754e3f2bda": {"doc_hash": "fb730a9937d32745145a2b99df209c4667b2c0253147f82d8bad9c272f1f7d70"}, "d4624850-71cb-4100-a7b6-6a0b1a7e0102": {"doc_hash": "a195e071bccb355c4ddae9d54a0c24c1b920d7ae05272cf56fd2d33015b5d7b7"}, "bd988c65-60df-4660-aa6f-e02c3cecee37": {"doc_hash": "c96493c11f62c568061727dfc3106d6203d645d73bcc9c25551414a2d348e31f"}, "6bc81f69-656f-4931-bf81-e1fc9d0c0b50": {"doc_hash": "caeec629b22b35d418e72d9d345ebdeca1765a335c69921d110a66626fbda517"}, "f99d7799-7fa7-4882-a981-42266cb0b39e": {"doc_hash": "ca273ec6b8b27307dfa53ab2103334be5f3a7492d50391e781731fc64dfeffff"}, "11c8d567-0709-439b-ab60-79dcdaecbecf": {"doc_hash": "d4837bc569b44eaf215ba3f0b90a08893be3d051cd367996c6a6abd6a4019b22"}, "fe14cba4-b29d-49ee-8bdb-d332c2fea693": {"doc_hash": "681f169d5f516075683f35b048efa33d729c3368547cd8e70a5a889a88dfac71"}, "eb9b2fc6-c87c-49f7-a403-f6018563d493": {"doc_hash": "eca397b3ec9351aecad2fe5f720274466d98d4b84d7525db307cc8eb7993ab67"}, "db184539-325a-4568-a3ed-941b207d1712": {"doc_hash": "f32e61a559b2ffd61bf4345f62f6491ea28da8730495c5a61c50ab9b59d024c5"}, "725ba586-f797-419c-b768-cf0ed22291fb": {"doc_hash": "d58adfc2f795bb01c0828b6a167a0fcac2e6e05ff79f98f9b4a6ffcc215e1f66"}, "79be2d67-3a6e-432b-9fcc-ff13297d9ecc": {"doc_hash": "f35870d3110169b8a8d356e1ccf5f317561bbf13781810e6cd3a6012a71de3f2"}, "3c060bcf-7778-467f-b68a-86a4d8c7731d": {"doc_hash": "aa96c50a0903bebf19886a0ee7cfa74fd4661f36f35058d34fa3d4a1a0d4e017"}, "fcb9cbae-c0d3-4c69-acc2-08c4d4f6a26b": {"doc_hash": "8d9495833c8b840eea18955a3d1732888db512da4337084c1a965b4de3514719"}, "21a080b7-60a2-4894-8c6c-ac325b560003": {"doc_hash": "00d1e3d05ab0d99587f37b902ece7d51920a86c0811a455e06d3c6d588bad249"}, "46093969-b21b-40f5-bf1e-e80d93ed82de": {"doc_hash": "90fe15f978dfb60b796ccaa3feba514c23fcef4c1b72ef288e44748673c07b11"}, "f2af6a4d-6deb-4163-bde0-36c46c8277ae": {"doc_hash": "bff89c297d793c2e8cb5f5cd4c68a2eb41d15995a0d37a02b260f5343565bf72"}, "f59b7f24-5cfd-47d8-a1c2-165f27b32426": {"doc_hash": "45923034b7b073b2024c94ad40e6a57aea189fe2642b5b3b536e3e30c43407ed"}, "67ac6131-905e-4d89-80c1-d39793d6d8d3": {"doc_hash": "bdc5fbcb629ec7ca9c3624017500ec9d0de989fa065c995ded95c6da5486420b"}, "2e9795bd-da32-4dab-b8de-a8b6f4dc1530": {"doc_hash": "011d56ec20509e5f560eab082da688493c25bb796a0d09a2f6b4357cbfa2faa7"}, "5dfed96b-8e5b-4955-828c-f4c76e8156d7": {"doc_hash": "96b3d24860be712ea796544f0915ee0a62156c17e01da659fe53d847fc9db4b2"}, "50305a8f-0fa2-4a8e-ad0d-48e22bacace2": {"doc_hash": "3daf6b72b453fdd9a9cbc1efcc396f6c1db422adbca6116ca0d790f7d3ef86e3"}, "3158e0f6-d646-465d-b98b-72d875e6053c": {"doc_hash": "b697740e6a958beeb108c9f40c8281337a1a0d59d488991ff1cd314ddc9516f8"}, "42444987-2e4a-439e-aa91-bf40a882e538": {"doc_hash": "c1d7e63dd21a4a388335d036d27f5e7fa27d0ff719235825040a45b3ee44ada7"}, "b50128db-52ab-4a47-b226-0cfa0a1742cb": {"doc_hash": "f43044f98475665b2fcd6ee90dc00add33bf17fb807819c8df94c7e170ee2256"}, "810626b3-5560-44be-a316-744f640c5c78": {"doc_hash": "59e1623aebd38b6f89ccc6acb8a6eccbfbb7ff5d264072b632c4cf5839331044"}, "352eb31e-0842-4949-95e0-c518bf52dc09": {"doc_hash": "bf84ba0e8cfc60e0edd31f264572b6361a178a712aa76a48f0a92f154a63851e"}, "54592802-7f9f-4988-be44-664393355a5a": {"doc_hash": "1c177d8da6be0ee8054b40f6f8b5ad5db852fd690a61ce78f20bd26f181c9c70"}, "e5e1bad7-8ee9-4e06-b29f-3d4a88642147": {"doc_hash": "49d226600b9f3e188c65d3c5d37fb0fee0fa3c800f7d85ce8db3c2a71be67a46"}, "dc814cca-4fc5-4baa-8eb8-2482b953294a": {"doc_hash": "d28121191b1d39eee6a845dac45b458670f3b2bc7098daa451d060cdc44343be"}, "c813ce0e-bcdc-4ee8-99a4-1c54edd71f25": {"doc_hash": "22b58f2f54a5fa19faed6b988de8da7a2002a0d15ef192dc7ef630c15e1d722d"}, "eb70dab8-d6a4-4e76-8e52-e6a1e93eb43c": {"doc_hash": "6845550f2e1d286862b18787ffc98a4b988776ecf63a09f761f80c25bdf12dea"}, "0022256e-98ce-4eda-98a5-1c034445e965": {"doc_hash": "efb55fbccf8e1e465a045fe437c653dc67361b3b64ac9f20ed549204fdaaae9f"}, "c770aa7d-fcaa-4d61-bb6d-6bc93ca39124": {"doc_hash": "cc3bd35f8719c01fd58b4d928bb5025e9778ad6e54e2cff30a06eecb902de0bb"}, "d2c5e0ba-093f-4e93-99d4-9acb0dfe1e68": {"doc_hash": "ba7f4a3efb479d34aa6c100068a60d410a2be9451cbc345029b6c5835ed927a6"}, "d08da341-4aaf-477a-bb4a-daf156bedf15": {"doc_hash": "5c524841b138249aae72aee8288917f89f6f54a18e197408bc80835da19b9f18"}, "0c4e7e71-8b00-425e-bd15-1db7040dec14": {"doc_hash": "7326a6a756904b0d6f229581122b549673aa51748ef38bd166e0c2db944068d3"}, "b6cabebd-d474-4017-96d9-488d79413d48": {"doc_hash": "ef8f8efd62f8e0346a43f5c7ada537341812d7d8d33d0bd8e1ff57773dfb563c"}, "646e2dde-6834-470b-85d1-6dd5cdd0f510": {"doc_hash": "e334fd543fef119a788d49ed23b6a073b7efb728f821866a6fb368552069e1da"}, "c6458907-aca3-4e16-a22d-61772dd0e8e6": {"doc_hash": "53c622a37ee32db448de4a79c602f964456b25d7231d44b715c4c9e650265c8e"}, "b8c40187-b311-4049-850a-e4013d585aaa": {"doc_hash": "a4d4863d186056d6f28429931f52bb98f516ae8f9a20a041e353547ca92d56f6"}, "f728d353-5d45-460e-b236-c9464ad9a5e3": {"doc_hash": "0de007af9943156fd13b03e5201cedc73c9f8b3ce18e26e0ab95922d2ac637ea"}, "f6d5c12d-7969-4901-8c34-f433d5af2f55": {"doc_hash": "11a8bc71c51c5b132c436f603e471332982521ae7e511a599a3eeba799d058d0"}, "e6ee149d-a762-4442-9ff3-e979ee862d5e": {"doc_hash": "d684b8f4eeca2a1eb8db51fe08eb5ddb25b881766e36519a8386fadee2ea5e42"}, "58a7575e-062c-4d70-9610-76d73d280466": {"doc_hash": "33923155b1387862298ffe33213503a61030a520e3711a8b227721a46febdbba"}, "d76846f4-ba1f-4388-a912-2b179c1d6a32": {"doc_hash": "39f0ff37a7ac143a14095ad4a7402faf92d3d35d41906fc410703a208d982225"}, "e0a7b1d4-5919-49df-8220-6fd497b3a503": {"doc_hash": "91fcfc5b4e250a80a71a9526e6d3f2b11b0912b64b1dc0802fe6dcdb23c5ba61"}, "6281c19c-55a9-41d3-93af-229ad650aa75": {"doc_hash": "c79eb82f3eb995006455f151706c7f78c31f07b1c449d57415f7ad58b5e1c973"}, "ddf84ac1-8359-44b1-afc5-5e0114d1377d": {"doc_hash": "e11929a235c180b840f82eb0b43123ff7b865deff9856c450c422bdcc048797b"}, "0c40755c-20f0-489f-8972-ffe818a6026f": {"doc_hash": "6d6ae207a733d9cd4961fb6e115dbbe167622258cdfdf7cee5ea442ab925e5f4"}, "8b9cf16b-5bf6-4492-b171-4a6d3cc5634a": {"doc_hash": "4f88ea9bf6fd781ee7f998e09b274d8315e199b2d997313d42f9e2184f973a0f"}, "b3642d3d-df0f-453c-b95e-05c2dffa59ee": {"doc_hash": "3d9050ef508ded5a38b02c5e517135a5affe8de5b059a31aee7ad1ca91c9d19c"}, "11f2bbbf-d12b-4c56-9213-9992d577c14a": {"doc_hash": "787f93f5ef18be43fe4faefbb1b66d710be74cbcdb924480631a82410d8b7ea1"}, "1feaf494-8818-4412-afe6-36a3da3d8e2f": {"doc_hash": "916318337558c98be1bedbf2c441a9e86955773666975f907767c321fb8de087"}, "93dab767-f321-4b33-8def-33046c994770": {"doc_hash": "dec248a85c097c652a2ddbff42a46fb4cfdf4674e11237a8079540ecace8b24a"}, "9fd61439-1513-4b66-beb4-0cd706b9964a": {"doc_hash": "69f45c1d2e45a74b47a1db77f2af1c1005a64dfd60baed53adb3920126689191"}, "2ff95f9d-148f-4c6c-bc71-04b610129e45": {"doc_hash": "7bf793b7ed187ac8b8358a2f29fa5946a16e09d32f8a539e153b381adb63b318"}, "40a247f5-831b-4436-be76-20c49b3416d1": {"doc_hash": "9782579d64a656d5836ac835dceee1bd99bd5da449585b8bc98e7fa11a8525b0"}, "8b0e5284-fc8a-45a6-8002-7b0f74760f5d": {"doc_hash": "1b6b4966713d1bcdee81230b415b2094d21e2f24c0ef3b3cfdadcb02757df585"}, "00fa9e5a-ff82-487e-b3a8-b5db3cbd5899": {"doc_hash": "b4d9b954b928035054dbbd717109e0c68ab4dad53af145b0a5529115bc3726d8"}, "91685a13-5134-413e-9148-b12a6ca02f40": {"doc_hash": "4f9a352dccf42be1305e1962a204b8f991c4ebaa79ff1ac9a1a4a3f5fe39e818"}, "4bbf861f-f3a0-4d89-a549-d48224ace0be": {"doc_hash": "9cd4b42ea99e5e7620af35b1fe3409851023592308e854bd2062cb49b7f08009"}, "5830c0ad-c9bf-405c-a751-aa69c3e847eb": {"doc_hash": "271a1c67ed0295127384839d155edcdedde3db63b09d798992a01863139bd22a"}, "732e8ffe-c6ca-4f60-a322-e56f74293d96": {"doc_hash": "184c875066e27ced58dbd299bf3f2c5885b75273613165e9f89e3dd6a9673fd6"}, "b574f218-fb6b-4cf4-ba42-39a894c6af2a": {"doc_hash": "eb256ad64e26d5a6b373ce5e1fa5eaf3545fb5ed0edcd89e3963f6dc6e1813b1"}, "5ed23912-cad5-4091-ab7d-ad1bc537457a": {"doc_hash": "9e979bbfa9183a2b0d646a1b7d2cb3cd24c628f578a57629cfd1917654103232"}, "1a235a14-b4b9-412a-b33c-8765f894555d": {"doc_hash": "d9d558f873dc3d98dfa54167c83a94a4dcb8109df029c7084fc312825c602f8f"}, "515a46bb-d1ab-411c-ba2b-cc094c49315a": {"doc_hash": "9d8ab5ba8d0075c0298c2d7d1bcf6a4de49468df25ad28b6ea636006918149aa"}, "2821bf66-16a8-4b94-90d7-e46e2e73c35a": {"doc_hash": "b967d688fd3b0604096562fb1c73947624f4d892bb53c58a949723f9819b6044"}, "3852a73d-4701-4629-bd2c-60e0a9fc3a11": {"doc_hash": "87b451d158b9da5fdb7aa37a229080b55a8f0207e8d4d273cc70097bafcb33bb"}, "1677de5e-20aa-40c2-820d-b4c3c90a5d5a": {"doc_hash": "cd97ee2990a38b9906ea3ebdf6f18b4bb596b45a503707a9569748190b92c2ae"}, "62be6dff-851b-4bf3-b31d-091d7d26b0d2": {"doc_hash": "9c27a9e39ffc48671a7cd8c57e481bed795a42dd298e331de1d296c6413abc8c"}, "d28f7364-0ace-4dad-bb92-86620a42231b": {"doc_hash": "f9a69f51ad2dac9f224174775a3d8030adb964fdf30c30dd255f5f54b1dc0223"}, "662119c8-92c5-4fbb-93cd-96de09c6721b": {"doc_hash": "9a9712b4c63846fdd7829ea4d1d0facf21d0ca314ef33059c609264c363741ae"}, "7b4c7ef2-cb7b-4c42-8f07-a111e1bd4aa7": {"doc_hash": "d9590b4a7abef033b5324cd0e3a04abd1defec5866448a04ad3443efcf0affee"}, "79984c12-046f-44f2-b67f-47bc4ced75c6": {"doc_hash": "819bd16ca976ef47ac7a69f5cd48bcdf755e9d7671a2df762205d37816daef4e"}, "17829cc8-425a-4921-b81c-a66034cc1fa4": {"doc_hash": "4621fb3b987c5a6978f713b396492a900c1dabdc3f92e93fd2c39ccab611f4e9"}, "24d82c56-31e1-4ed1-bbda-f5b1fe7033fa": {"doc_hash": "a9e81a6470c7a42a6a7d44c59553785ae0a4f040ef17c16423dd89e41f44ed13"}, "157d4e59-d8bc-4970-a501-61d3b3447588": {"doc_hash": "566ebeefb0fc5249347288c4888cf45cc0e493b2f2ccacfd44c5353a320ff038"}, "75e0c4f2-1c1e-41dc-ad32-fc819ff03365": {"doc_hash": "e620c00a65b70a82394de5050ab266185fcbc7b1b86bdec9cd59c17b7d4b8e4e"}, "78a3d669-2ba9-4a4c-8ae5-13c8e415bdfc": {"doc_hash": "6e7747f19cd6483636988033453a9c7207ac165cbe75813f3e2eda7c36d523c8"}, "4a67e605-011e-4481-933a-e60a147cf5d2": {"doc_hash": "0456468909fa48748ae951861303bafb1cd89bf19938f05a97fd4fae38712f15"}, "c7a65a0f-de49-45b9-9cec-79cc94ee5ea3": {"doc_hash": "0a28f4cdac8b3c2f0e5210cfc62841d0accb84d619a2348f49ce8c90e008b698"}, "865f170b-a4b2-4df8-a4e1-8fe54b46ce33": {"doc_hash": "5a744060a761980f973ccd6c06c6ff07d49c75a1d8084c7a16107347cf13ba67"}, "d85d8bb7-838b-44c5-ab16-a287e6f89818": {"doc_hash": "fe6e42d7a27093a24b6d622e709e6992981f19a5b2b88850f3dcc06290f484c6"}, "c12087cf-181c-459d-a61f-d840175f99b5": {"doc_hash": "6ad2ec31c073ae60e795019960ee5db8f5641a2a448b625775567dbe5b13a679"}, "1457c5f6-1b1a-4461-b9dc-840f1fd61af3": {"doc_hash": "157c5e768e8ed8031dfbd2be7ad8ad332d951edbc780ac297fbb7c55ce017ad9"}, "2f071c06-dd5f-4340-9a3b-6823eb1572d6": {"doc_hash": "5a0d806f9e777ea43bcb5589d74eac72802f258fea1f7609e1c9f9fed65ddc0f"}, "eb71b480-608e-43bb-8352-3a75ce55d905": {"doc_hash": "f2cc8fd6e98bf25fe0dcde84769463c6ccf51bc8b6116a8edcd7d7f5ddb88b03"}, "4d0a96b8-257c-42e3-a5ac-37aacbb72dca": {"doc_hash": "9c5a21cb184b97b5ceb1aeaef60c657123b3bc524f061551c1f123e87326955a"}, "4746ec2f-d6a6-4308-9a85-c66baa59585e": {"doc_hash": "18b68cbffe287b6a949c96acbb5d3f5a339efde6b4161b20c835a32cda39bc23"}, "4bd63418-5e11-4071-b78b-44617421b1d3": {"doc_hash": "4a3253d5dcfe2261dd589727ab5ac08f425b0dc1c9a8132313f841edf0698ca8"}, "e6a3c1ed-ec02-4970-a4a2-0c33a15be447": {"doc_hash": "d86683dbb11ef8223d41144bfad3e178f2878010f13a756bef30c18fdea62e13"}, "3ea9a0d4-38d6-4581-8f95-689943d3f699": {"doc_hash": "caeec629b22b35d418e72d9d345ebdeca1765a335c69921d110a66626fbda517"}}, "docstore/data": {"f99d7799-7fa7-4882-a981-42266cb0b39e": {"__data__": {"text": "---\ntitle: Integrations\n---\n\n## Preprocessors\n\nPreprocessors transform your `.svelte` files before passing them to the compiler. For example, if your `.svelte` file uses TypeScript and PostCSS, it must first be transformed into JavaScript and CSS so that the Svelte compiler can handle it. There are many [available preprocessors](https://sveltesociety.dev/tools#preprocessors). The Svelte team maintains two official ones discussed below.\n\n### `vitePreprocess`\n\n`vite-plugin-svelte` offers a [`vitePreprocess`](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/preprocess.md) feature which utilizes Vite for preprocessing. It is capable of handling the language flavors Vite handles: TypeScript, PostCSS, SCSS, Less, Stylus, and SugarSS. For convenience, it is re-exported from the `@sveltejs/kit/vite` package. If you set your project up with TypeScript it will be included by default:\n\n```js\n// svelte.config.js\nimport { vitePreprocess } from '@sveltejs/kit/vite';\n\nexport default {\n  preprocess: [vitePreprocess()]\n};\n```\n\n### `svelte-preprocess`\n\n`svelte-preprocess` has some additional functionality not found in `vitePreprocess` such as support for Pug, Babel, and global styles. However, `vitePreprocess` may be faster and require less configuration, so it is used by default. Note that CoffeeScript is [not supported](https://github.com/sveltejs/kit/issues/2920#issuecomment-996469815) by SvelteKit.\n\nYou will need to install `svelte-preprocess` with `npm install --save-dev svelte-preprocess` and [add it to your `svelte.config.js`](https://github.com/sveltejs/svelte-preprocess/blob/main/docs/usage.md#with-svelte-config). After that, you will often need to [install the corresponding library](https://github.com/sveltejs/svelte-preprocess/blob/main/docs/getting-started.md) such as `npm install -D sass` or `npm install -D less`.\n\n## Adders\n\n[Svelte Adders](https://sveltesociety.dev/templates#adders) allow you to setup many different complex integrations like Tailwind, PostCSS, Storybook, Firebase, GraphQL, mdsvex, and more with a single command. Please see [sveltesociety.dev](https://sveltesociety.dev/) for a full listing of templates, components, and tools available for use with Svelte and SvelteKit.\n\n## Integration FAQs\n\nThe SvelteKit FAQ has a [section on integrations](../faq#integrations), which may be helpful if you still have questions.\n", "doc_id": "f99d7799-7fa7-4882-a981-42266cb0b39e", "embedding": null, "doc_hash": "ca273ec6b8b27307dfa53ab2103334be5f3a7492d50391e781731fc64dfeffff", "extra_info": null, "node_info": {"start": 0, "end": 2378, "_node_type": "1"}, "relationships": {"1": "4007e36c-fc31-4ee2-af62-4e02d815b214"}}, "__type__": "1"}, "11c8d567-0709-439b-ab60-79dcdaecbecf": {"__data__": {"text": "---\ntitle: Accessibility\n---\n\nSvelteKit strives to provide an accessible platform for your app by default. Svelte's [compile-time accessibility checks](https://svelte.dev/docs#accessibility-warnings) will also apply to any SvelteKit application you build.\n\nHere's how SvelteKit's built-in accessibility features work and what you need to do to help these features to work as well as possible. Keep in mind that while SvelteKit provides an accessible foundation, you are still responsible for making sure your application code is accessible. If you're new to accessibility, see the [\"further reading\"](accessibility#further-reading) section of this guide for additional resources.\n\nWe recognize that accessibility can be hard to get right. If you want to suggest improvements to how SvelteKit handles accessibility, please [open a GitHub issue](https://github.com/sveltejs/kit/issues).\n\n## Route announcements\n\nIn traditional server-rendered applications, every navigation (e.g. clicking on an `<a>` tag) triggers a full page reload. When this happens, screen readers and other assistive technology will read out the new page's title so that users understand that the page has changed.\n\nSince navigation between pages in SvelteKit happens without reloading the page (known as [client-side routing](glossary#routing)), SvelteKit injects a [live region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) onto the page that will read out the new page name after each navigation. This determines the page name to announce by inspecting the `<title>` element.\n\nBecause of this behavior, every page in your app should have a unique, descriptive title. In SvelteKit, you can do this by placing a `<svelte:head>` element on each page:\n\n```svelte\n/// file: src/routes/+page.svelte\n<svelte:head>\n\t<title>Todo List</title>\n</svelte:head>\n```\n\nThis will allow screen readers and other assistive technology to identify the new page after a navigation occurs. Providing a descriptive title is also important for [SEO](seo#manual-setup-title-and-meta).\n\n## Focus management\n\nIn traditional server-rendered applications, every navigation will reset focus to the top of the page. This ensures that people browsing the web with a keyboard or screen reader will start interacting with the page from the beginning.\n\nTo simulate this behavior during client-side routing, SvelteKit focuses the `<body>` element after each navigation and [enhanced form submission](https://kit.svelte.dev/docs/form-actions#progressive-enhancement). There is one exception - if an element with the [`autofocus`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus) attribute is present, SvelteKit will focus that element instead. Make sure to [consider the implications for assistive technology](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus#accessibility_considerations) when using that attribute.\n\nIf you want to customize SvelteKit's focus management, you can use the `afterNavigate` hook:\n\n```js\n/// <reference types=\"@sveltejs/kit\" />\n// ---cut---\nimport { afterNavigate } from '$app/navigation';\n\nafterNavigate(() => {\n\t/** @type {HTMLElement | null} */\n\tconst to_focus = document.querySelector('.focus-me');\n\tto_focus?.focus();\n});\n```\n\nYou can also programmatically navigate to a different page using the [`goto`](modules#$app-navigation-goto) function. By default, this will have the same client-side routing behavior as clicking on a link. However, `goto` also accepts a `keepFocus` option that will preserve the currently-focused element instead of resetting focus. If you enable", "doc_id": "11c8d567-0709-439b-ab60-79dcdaecbecf", "embedding": null, "doc_hash": "d4837bc569b44eaf215ba3f0b90a08893be3d051cd367996c6a6abd6a4019b22", "extra_info": null, "node_info": {"start": 0, "end": 3639, "_node_type": "1"}, "relationships": {"1": "a284a99e-4d80-444f-9aff-a2cf11c03638", "3": "fe14cba4-b29d-49ee-8bdb-d332c2fea693"}}, "__type__": "1"}, "fe14cba4-b29d-49ee-8bdb-d332c2fea693": {"__data__": {"text": "option that will preserve the currently-focused element instead of resetting focus. If you enable this option, make sure the currently-focused element still exists on the page after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users.\n\n## The \"lang\" attribute\n\nBy default, SvelteKit's page template sets the default language of the document to English. If your content is not in English, you should update the `<html>` element in `src/app.html` to have the correct [`lang`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang#accessibility) attribute. This will ensure that any assistive technology reading the document uses the correct pronunciation. For example, if your content is in German, you should update `app.html` to the following:\n\n```html\n/// file: src/app.html\n<html lang=\"de\">\n```\n\nIf your content is available in multiple languages, you should set the `lang` attribute based on the language of the current page. You can do this with SvelteKit's [handle hook](hooks#server-hooks-handle):\n\n```html\n/// file: src/app.html\n<html lang=\"%lang%\">\n```\n\n```js\n/// file: src/hooks.server.js\n/**\n * @param {import('@sveltejs/kit').RequestEvent} event\n */\nfunction get_lang(event) {\n\treturn 'en';\n}\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport function handle({ event, resolve }) {\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('%lang%', get_lang(event))\n\t});\n}\n```\n\n## Further reading\n\nFor the most part, building an accessible SvelteKit app is the same as building an accessible web app. You should be able to apply information from the following general accessibility resources to any web experience you build:\n\n- [MDN Web Docs: Accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility)\n- [The A11y Project](https://www.a11yproject.com/)\n- [How to Meet WCAG (Quick Reference)](https://www.w3.org/WAI/WCAG21/quickref/)\n", "doc_id": "fe14cba4-b29d-49ee-8bdb-d332c2fea693", "embedding": null, "doc_hash": "681f169d5f516075683f35b048efa33d729c3368547cd8e70a5a889a88dfac71", "extra_info": null, "node_info": {"start": 3542, "end": 5544, "_node_type": "1"}, "relationships": {"1": "a284a99e-4d80-444f-9aff-a2cf11c03638", "2": "11c8d567-0709-439b-ab60-79dcdaecbecf"}}, "__type__": "1"}, "eb9b2fc6-c87c-49f7-a403-f6018563d493": {"__data__": {"text": "---\ntitle: Advanced routing\n---\n\n## Rest parameters\n\nIf the number of route segments is unknown, you can use rest syntax \u2014 for example you might implement GitHub's file viewer like so...\n\n```bash\n/[org]/[repo]/tree/[branch]/[...file]\n```\n\n...in which case a request for `/sveltejs/kit/tree/master/documentation/docs/04-advanced-routing.md` would result in the following parameters being available to the page:\n\n```js\n// @noErrors\n{\n\torg: 'sveltejs',\n\trepo: 'kit',\n\tbranch: 'master',\n\tfile: 'documentation/docs/04-advanced-routing.md'\n}\n```\n\n> `src/routes/a/[...rest]/z/+page.svelte` will match `/a/z` (i.e. there's no parameter at all) as well as `/a/b/z` and `/a/b/c/z` and so on. Make sure you check that the value of the rest parameter is valid, for example using a [matcher](#matching).\n\n### 404 pages\n\nRest parameters also allow you to render custom 404s. Given these routes...\n\n```\nsrc/routes/\n\u251c marx-brothers/\n\u2502 \u251c chico/\n\u2502 \u251c harpo/\n\u2502 \u251c groucho/\n\u2502 \u2514 +error.svelte\n\u2514 +error.svelte\n```\n\n...the `marx-brothers/+error.svelte` file will _not_ be rendered if you visit `/marx-brothers/karl`, because no route was matched. If you want to render the nested error page, you should create a route that matches any `/marx-brothers/*` request, and return a 404 from it:\n\n```diff\nsrc/routes/\n\u251c marx-brothers/\n+| \u251c [...path]/\n\u2502 \u251c chico/\n\u2502 \u251c harpo/\n\u2502 \u251c groucho/\n\u2502 \u2514 +error.svelte\n\u2514 +error.svelte\n```\n\n```js\n/// file: src/routes/marx-brothers/[...path]/+page.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\tthrow error(404, 'Not Found');\n}\n```\n\n> If you don't handle 404 cases, they will appear in [`handleError`](hooks#shared-hooks-handleerror)\n\n## Optional parameters\n\nA route like `[lang]/home` contains a parameter named `lang` which is required. Sometimes it's beneficial to make these parameters optional, so that in this example both `home` and `en/home` point to the same page. You can do that by wrapping the parameter in another bracket pair: `[[lang]]/home`\n\nNote that an optional route parameter cannot follow a rest parameter (`[...rest]/[[optional]]`), since parameters are matched 'greedily' and the optional parameter would always be unused.\n\n## Matching\n\nA route like `src/routes/archive/[page]` would match `/archive/3`, but it would also match `/archive/potato`. We don't want that. You can ensure that route parameters are well-formed by adding a _matcher_ \u2014 which takes the parameter string (`\"3\"` or `\"potato\"`) and returns `true` if it is valid \u2014 to your [`params`](configuration#files) directory...\n\n```js\n/// file: src/params/integer.js\n/** @type {import('@sveltejs/kit').ParamMatcher} */\nexport function match(param) {\n\treturn /^\\d+$/.test(param);\n}\n```\n\n...and augmenting your", "doc_id": "eb9b2fc6-c87c-49f7-a403-f6018563d493", "embedding": null, "doc_hash": "eca397b3ec9351aecad2fe5f720274466d98d4b84d7525db307cc8eb7993ab67", "extra_info": null, "node_info": {"start": 0, "end": 2762, "_node_type": "1"}, "relationships": {"1": "99eba38d-9650-476b-9d95-4c2ea3e10aa1", "3": "db184539-325a-4568-a3ed-941b207d1712"}}, "__type__": "1"}, "db184539-325a-4568-a3ed-941b207d1712": {"__data__": {"text": "augmenting your routes:\n\n```diff\n-src/routes/archive/[page]\n+src/routes/archive/[page=integer]\n```\n\nIf the pathname doesn't match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404.\n\nEach module in the `params` directory corresponds to a matcher, with the exception of `*.test.js` and `*.spec.js` files which may be used to unit test your matchers.\n\n> Matchers run both on the server and in the browser.\n\n## Sorting\n\nIt's possible for multiple routes to match a given path. For example each of these routes would match `/foo-abc`:\n\n```bash\nsrc/routes/[...catchall]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/foo-abc/+page.svelte\n```\n\nSvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...\n\n- More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on)\n- Parameters with [matchers](#matching) (`[name=type]`) are higher priority than those without (`[name]`)\n- `[[optional]]` and `[...rest]` parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words `x/[[y]]/z` is treated equivalently to `x/z` for the purposes of sorting\n- Ties are resolved alphabetically\n\n...resulting in this ordering, meaning that `/foo-abc` will invoke `src/routes/foo-abc/+page.svelte`, and `/foo-def` will invoke `src/routes/foo-[c]/+page.svelte` rather than less specific routes:\n\n```bash\nsrc/routes/foo-abc/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/[...catchall]/+page.svelte\n```\n\n## Encoding\n\nSome characters can't be used on the filesystem \u2014 `/` on Linux and Mac, `\\ / : * ? \" < > |` on Windows. The `#` and `%` characters have special meaning in URLs, and the `[ ] ( )` characters have special meaning to SvelteKit, so these also can't be used directly as part of your route.\n\nTo use these characters in your routes, you can use hexadecimal escape sequences, which have the format `[x+nn]` where `nn` is a hexadecimal character code:\n\n- `\\` \u2014 `[x+5c]`\n- `/` \u2014 `[x+2f]`\n- `:` \u2014 `[x+3a]`\n- `*` \u2014 `[x+2a]`\n- `?` \u2014 `[x+3f]`\n- `\"` \u2014 `[x+22]`\n- `<` \u2014 `[x+3c]`\n- `>` \u2014 `[x+3e]`\n- `|` \u2014 `[x+7c]`\n- `#` \u2014 `[x+23]`\n- `%` \u2014 `[x+25]`\n- `[` \u2014 `[x+5b]`\n- `]` \u2014 `[x+5d]`\n- `(` \u2014 `[x+28]`\n- `)` \u2014 `[x+29]`\n\nFor example, to create a `/smileys/:-)` route, you would create a `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`", "doc_id": "db184539-325a-4568-a3ed-941b207d1712", "embedding": null, "doc_hash": "f32e61a559b2ffd61bf4345f62f6491ea28da8730495c5a61c50ab9b59d024c5", "extra_info": null, "node_info": {"start": 2749, "end": 5366, "_node_type": "1"}, "relationships": {"1": "99eba38d-9650-476b-9d95-4c2ea3e10aa1", "2": "eb9b2fc6-c87c-49f7-a403-f6018563d493", "3": "725ba586-f797-419c-b768-cf0ed22291fb"}}, "__type__": "1"}, "725ba586-f797-419c-b768-cf0ed22291fb": {"__data__": {"text": "file.\n\nYou can determine the hexadecimal code for a character with JavaScript:\n\n```js\n':'.charCodeAt(0).toString(16); // '3a', hence '[x+3a]'\n```\n\nYou can also use Unicode escape sequences. Generally you won't need to as you can use the unencoded character directly, but if \u2014 for some reason \u2014 you can't have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:\n\n```\nsrc/routes/[u+d83e][u+dd2a]/+page.svelte\nsrc/routes/\ud83e\udd2a/+page.svelte\n```\n\nThe format for a Unicode escape sequence is `[u+nnnn]` where `nnnn` is a valid value between `0000` and `10ffff`. (Unlike JavaScript string escaping, there's no need to use surrogate pairs to represent code points above `ffff`.) To learn more about Unicode encodings, consult [Programming with Unicode](https://unicodebook.readthedocs.io/unicode_encodings.html).\n\n> Since TypeScript [struggles](https://github.com/microsoft/TypeScript/issues/13399) with directories with a leading `.` character, you may find it useful to encode these characters when creating e.g. [`.well-known`](https://en.wikipedia.org/wiki/Well-known_URI) routes: `src/routes/[x+2e]well-known/...`\n\n## Advanced layouts\n\nBy default, the _layout hierarchy_ mirrors the _route hierarchy_. In some cases, that might not be what you want.\n\n### (group)\n\nPerhaps you have some routes that are 'app' routes that should have one layout (e.g. `/dashboard` or `/item`), and others that are 'marketing' routes that should have a different layout (`/blog` or `/testimonials`). We can group these routes with a directory whose name is wrapped in parentheses \u2014 unlike normal directories, `(app)` and `(marketing)` do not affect the URL pathname of the routes inside them:\n\n```diff\nsrc/routes/\n+\u2502 (app)/\n\u2502 \u251c dashboard/\n\u2502 \u251c item/\n\u2502 \u2514 +layout.svelte\n+\u2502 (marketing)/\n\u2502 \u251c about/\n\u2502 \u251c testimonials/\n\u2502 \u2514 +layout.svelte\n\u251c admin/\n\u2514 +layout.svelte\n```\n\nYou can also put a `+page` directly inside a `(group)`, for example if `/` should be an `(app)` or a `(marketing)` page.\n\n### Breaking out of layouts\n\nThe root layout applies to every page of your app \u2014 if omitted, it defaults to `<slot />`. If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups _except_ the routes that should not inherit the common layouts.\n\nIn the example above, the `/admin` route does not inherit either the `(app)` or `(marketing)` layouts.\n\n### +page@\n\nPages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an `/item/[id]/embed` route inside the `(app)` group from the previous example:\n\n```diff\nsrc/routes/\n\u251c (app)/\n\u2502 \u251c item/\n\u2502 \u2502 \u251c [id]/\n\u2502 \u2502 \u2502 \u251c embed/\n+\u2502 \u2502 \u2502 \u2502 \u2514 +page.svelte\n\u2502 \u2502 \u2502 \u2514 +layout.svelte\n\u2502 \u2502 \u2514 +layout.svelte\n\u2502 \u2514 +layout.svelte\n\u2514 +layout.svelte\n```\n\nOrdinarily, this would inherit the root layout, the `(app)` layout, the `item` layout and the", "doc_id": "725ba586-f797-419c-b768-cf0ed22291fb", "embedding": null, "doc_hash": "d58adfc2f795bb01c0828b6a167a0fcac2e6e05ff79f98f9b4a6ffcc215e1f66", "extra_info": null, "node_info": {"start": 5381, "end": 8290, "_node_type": "1"}, "relationships": {"1": "99eba38d-9650-476b-9d95-4c2ea3e10aa1", "2": "db184539-325a-4568-a3ed-941b207d1712", "3": "79be2d67-3a6e-432b-9fcc-ff13297d9ecc"}}, "__type__": "1"}, "79be2d67-3a6e-432b-9fcc-ff13297d9ecc": {"__data__": {"text": "the root layout, the `(app)` layout, the `item` layout and the `[id]` layout. We can reset to one of those layouts by appending `@` followed by the segment name \u2014 or, for the root layout, the empty string. In this example, we can choose from the following options:\n\n- `+page@[id].svelte` - inherits from `src/routes/(app)/item/[id]/+layout.svelte`\n- `+page@item.svelte` - inherits from `src/routes/(app)/item/+layout.svelte`\n- `+page@(app).svelte` - inherits from `src/routes/(app)/+layout.svelte`\n- `+page@.svelte` - inherits from `src/routes/+layout.svelte`\n\n```diff\nsrc/routes/\n\u251c (app)/\n\u2502 \u251c item/\n\u2502 \u2502 \u251c [id]/\n\u2502 \u2502 \u2502 \u251c embed/\n+\u2502 \u2502 \u2502 \u2502 \u2514 +page@(app).svelte\n\u2502 \u2502 \u2502 \u2514 +layout.svelte\n\u2502 \u2502 \u2514 +layout.svelte\n\u2502 \u2514 +layout.svelte\n\u2514 +layout.svelte\n```\n\n### +layout@\n\nLike pages, layouts can _themselves_ break out of their parent layout hierarchy, using the same technique. For example, a `+layout@.svelte` component would reset the hierarchy for all its child routes.\n\n```\nsrc/routes/\n\u251c (app)/\n\u2502 \u251c item/\n\u2502 \u2502 \u251c [id]/\n\u2502 \u2502 \u2502 \u251c embed/\n\u2502 \u2502 \u2502 \u2502 \u2514 +page.svelte  // uses (app)/item/[id]/+layout.svelte\n\u2502 \u2502 \u2502 \u251c +layout.svelte  // inherits from (app)/item/+layout@.svelte\n\u2502 \u2502 \u2502 \u2514 +page.svelte    // uses (app)/item/+layout@.svelte\n\u2502 \u2502 \u2514 +layout@.svelte   // inherits from root layout, skipping (app)/+layout.svelte\n\u2502 \u2514 +layout.svelte\n\u2514 +layout.svelte\n```\n\n### When to use layout groups\n\nNot all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex `(group)` nesting, or that you don't want to introduce a `(group)` for a single outlier. It's perfectly fine to use other means such as composition (reusable `load` functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:\n\n```svelte\n/// file: src/routes/nested/route/+layout@.svelte\n<script>\n\timport ReusableLayout from '$lib/ReusableLayout.svelte';\n\texport let data;\n</script>\n\n<ReusableLayout {data}>\n\t<slot />\n</ReusableLayout>\n```\n\n```js\n/// file: src/routes/nested/route/+layout.js\n// @filename: ambient.d.ts\ndeclare module \"$lib/reusable-load-function\" {\n\texport function reusableLoad(event: import('@sveltejs/kit').LoadEvent): Promise<Record<string, any>>;\n}\n// @filename: index.js\n// ---cut---\nimport { reusableLoad } from '$lib/reusable-load-function';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\t// Add additional logic here, if needed\n\treturn reusableLoad(event);\n}\n```\n\n## Further reading\n\n- [Tutorial: Advanced Routing](https://learn.svelte.dev/tutorial/optional-params)\n", "doc_id": "79be2d67-3a6e-432b-9fcc-ff13297d9ecc", "embedding": null, "doc_hash": "f35870d3110169b8a8d356e1ccf5f317561bbf13781810e6cd3a6012a71de3f2", "extra_info": null, "node_info": {"start": 8228, "end": 10914, "_node_type": "1"}, "relationships": {"1": "99eba38d-9650-476b-9d95-4c2ea3e10aa1", "2": "725ba586-f797-419c-b768-cf0ed22291fb"}}, "__type__": "1"}, "3c060bcf-7778-467f-b68a-86a4d8c7731d": {"__data__": {"text": "---\ntitle: Building your app\n---\n\nBuilding a SvelteKit app happens in two stages, which both happen when you run `vite build` (usually via `npm run build`).\n\nFirstly, Vite creates an optimized production build of your server code, your browser code, and your service worker (if you have one). [Prerendering](page-options#prerender) is executed at this stage, if appropriate.\n\nSecondly, an _adapter_ takes this production build and tunes it for your target environment \u2014 more on this on the following pages.\n\n## During the build\n\nSvelteKit will load your `+page/layout(.server).js` files (and all files they import) for analysis during the build. Any code that should _not_ be executed at this stage must check that `building` from [`$app/environment`](modules#$app-environment) is `false`:\n\n```diff\n+import { building } from '$app/environment';\nimport { setupMyDatabase } from '$lib/server/database';\n\n+if (!building) {\n\tsetupMyDatabase();\n+}\n\nexport function load() {\n\t// ...\n}\n```\n\n## Preview your app\n\nAfter building, you can view your production build locally with `vite preview` (via `npm run preview`). Note that this will run the app in Node, and so is not a perfect reproduction of your deployed app \u2014 adapter-specific adjustments like the [`platform` object](adapters#platform-specific-context) do not apply to previews.\n", "doc_id": "3c060bcf-7778-467f-b68a-86a4d8c7731d", "embedding": null, "doc_hash": "aa96c50a0903bebf19886a0ee7cfa74fd4661f36f35058d34fa3d4a1a0d4e017", "extra_info": null, "node_info": {"start": 0, "end": 1330, "_node_type": "1"}, "relationships": {"1": "05204e97-d059-4dbe-96b6-3b4ff7b214ce"}}, "__type__": "1"}, "fcb9cbae-c0d3-4c69-acc2-08c4d4f6a26b": {"__data__": {"text": "---\ntitle: Configuration\n---\n\nYour project's configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.\n\n```js\n/// file: svelte.config.js\n// @filename: ambient.d.ts\ndeclare module '@sveltejs/adapter-auto' {\n\tconst plugin: () => import('@sveltejs/kit').Adapter;\n\texport default plugin;\n}\n\n// @filename: index.js\n// ---cut---\nimport adapter from '@sveltejs/adapter-auto';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n\nexport default config;\n```\n\n> TYPES: @sveltejs/kit#Config\n\nThe `kit` property configures SvelteKit, and can have the following properties:\n\n> EXPANDED_TYPES: @sveltejs/kit#KitConfig", "doc_id": "fcb9cbae-c0d3-4c69-acc2-08c4d4f6a26b", "embedding": null, "doc_hash": "8d9495833c8b840eea18955a3d1732888db512da4337084c1a965b4de3514719", "extra_info": null, "node_info": {"start": 0, "end": 791, "_node_type": "1"}, "relationships": {"1": "9f1b006b-e9fd-4c13-9850-0eaa1ed8c649"}}, "__type__": "1"}, "21a080b7-60a2-4894-8c6c-ac325b560003": {"__data__": {"text": "---\ntitle: Introduction\n---\n\n## Before we begin\n\n> If you're new to Svelte or SvelteKit we recommend checking out the [interactive tutorial](https://learn.svelte.dev).\n>\n> If you get stuck, reach out for help in the [Discord chatroom](https://svelte.dev/chat).\n\n## What is SvelteKit?\n\nSvelteKit is a framework for rapidly developing robust, performant web applications using [Svelte](https://svelte.dev/). If you're coming from React, SvelteKit is similar to Next. If you're coming from Vue, SvelteKit is similar to Nuxt.\n\n## What is Svelte?\n\nIn short, Svelte is a way of writing user interface components \u2014 like a navigation bar, comment section, or contact form \u2014 that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don't need to know Svelte to understand the rest of this guide, but it will help. If you'd like to learn more, check out [the Svelte tutorial](https://svelte.dev/tutorial).\n\n## SvelteKit vs Svelte\n\nSvelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.\n\nSvelteKit provides basic functionality like a [router](glossary#routing) \u2014 which updates the UI when a link is clicked \u2014 and [server-side rendering (SSR)](glossary#ssr). But beyond that, building an app with all the modern best practices is fiendishly complicated. Those practices include [build optimizations](https://vitejs.dev/guide/features.html#build-optimizations), so that you load only the minimal required code; [offline support](service-workers); [preloading](link-options#data-sveltekit-preload-data) pages before the user initiates navigation; [configurable rendering](page-options) that allows you to render different parts of your app on the server with [SSR](glossary#ssr), in the browser [client-side rendering](glossary#csr), or at build-time with [prerendering](glossary#prerendering); and many other things. SvelteKit does all the boring stuff for you so that you can get on with the creative part.\n\nIt reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging [Vite](https://vitejs.dev/) with a [Svelte plugin](https://github.com/sveltejs/vite-plugin-svelte) to do [Hot Module Replacement (HMR)](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/config.md#hot).\n", "doc_id": "21a080b7-60a2-4894-8c6c-ac325b560003", "embedding": null, "doc_hash": "00d1e3d05ab0d99587f37b902ece7d51920a86c0811a455e06d3c6d588bad249", "extra_info": null, "node_info": {"start": 0, "end": 2500, "_node_type": "1"}, "relationships": {"1": "95979001-4675-4e7b-9844-cf8470b541fc"}}, "__type__": "1"}, "46093969-b21b-40f5-bf1e-e80d93ed82de": {"__data__": {"text": "---\ntitle: Migrating from Sapper\nrank: 1\n---\n\nSvelteKit is the successor to Sapper and shares many elements of its design.\n\nIf you have an existing Sapper app that you plan to migrate to SvelteKit, there are a number of changes you will need to make. You may find it helpful to view [some examples](additional-resources#examples) while migrating.\n\n## package.json\n\n### type: \"module\"\n\nAdd `\"type\": \"module\"` to your `package.json`. You can do this step separately from the rest as part of an incremental migration if you are using Sapper 0.29.3\nor newer.\n\n### dependencies\n\nRemove `polka` or `express`, if you're using one of those, and any middleware such as `sirv` or `compression`.\n\n### devDependencies\n\nRemove `sapper` from your `devDependencies` and replace it with `@sveltejs/kit` and whichever [adapter](adapters) you plan to use (see [next section](migrating#project-files-configuration)).\n\n### scripts\n\nAny scripts that reference `sapper` should be updated:\n\n- `sapper build` should become `vite build` using the Node [adapter](adapters)\n- `sapper export` should become `vite build` using the static [adapter](adapters)\n- `sapper dev` should become `vite dev`\n- `node __sapper__/build` should become `node build`\n\n## Project files\n\nThe bulk of your app, in `src/routes`, can be left where it is, but several project files will need to be moved or updated.\n\n### Configuration\n\nYour `webpack.config.js` or `rollup.config.js` should be replaced with a `svelte.config.js`, as documented [here](configuration). Svelte preprocessor options should be moved to `config.preprocess`.\n\nYou will need to add an [adapter](adapters). `sapper build` is roughly equivalent to [adapter-node](https://github.com/sveltejs/kit/tree/master/packages/adapter-node) while `sapper export` is roughly equivalent to [adapter-static](https://github.com/sveltejs/kit/tree/master/packages/adapter-static), though you might prefer to use an adapter designed for the platform you're deploying to.\n\nIf you were using plugins for filetypes that are not automatically handled by [Vite](https://vitejs.dev), you will need to find Vite equivalents and add them to the [Vite config](project-structure#project-files-vite-config-js).\n\n### src/client.js\n\nThis file has no equivalent in SvelteKit. Any custom logic (beyond `sapper.start(...)`) should be expressed in your `+layout.svelte` file, inside an `onMount` callback.\n\n### src/server.js\n\nWhen using `adapter-node` the equivalent is a [custom server](adapter-node#custom-server). Otherwise, this file has no direct equivalent, since SvelteKit apps can run in serverless environments.\n\n### src/service-worker.js\n\nMost imports from `@sapper/service-worker` have equivalents in [`$service-worker`](modules#$service-worker):\n\n- `files` is unchanged\n- `routes` has been removed\n- `shell` is now `build`\n- `timestamp` is now `version`\n\n### src/template.html\n\nThe `src/template.html` file should be renamed `src/app.html`.\n\nRemove `%sapper.base%`, `%sapper.scripts%` and `%sapper.styles%`. Replace `%sapper.head%` with `%sveltekit.head%` and `%sapper.html%` with `%sveltekit.body%`. The `<div id=\"sapper\">` is no longer necessary.\n\n### src/node_modules\n\nA common pattern in Sapper apps is to put your internal library in a directory inside `src/node_modules`. This doesn't", "doc_id": "46093969-b21b-40f5-bf1e-e80d93ed82de", "embedding": null, "doc_hash": "90fe15f978dfb60b796ccaa3feba514c23fcef4c1b72ef288e44748673c07b11", "extra_info": null, "node_info": {"start": 0, "end": 3288, "_node_type": "1"}, "relationships": {"1": "d051101a-0d69-43f7-acdc-c836532b57ac", "3": "f2af6a4d-6deb-4163-bde0-36c46c8277ae"}}, "__type__": "1"}, "f2af6a4d-6deb-4163-bde0-36c46c8277ae": {"__data__": {"text": "is to put your internal library in a directory inside `src/node_modules`. This doesn't work with Vite, so we use [`src/lib`](modules#$lib) instead.\n\n## Pages and layouts\n\n### Renamed files\n\nRoutes now are made up of the folder name exclusively to remove ambiguity, the folder names leading up to a `+page.svelte` correspond to the route. See [the routing docs](routing) for an overview. The following shows a old/new comparison:\n\n| Old                       | New                       |\n| ------------------------- | ------------------------- |\n| routes/about/index.svelte | routes/about/+page.svelte |\n| routes/about.svelte       | routes/about/+page.svelte |\n\nYour custom error page component should be renamed from `_error.svelte` to `+error.svelte`. Any `_layout.svelte` files should likewise be renamed `+layout.svelte`. [Any other files are ignored](routing#other-files).\n\n### Imports\n\nThe `goto`, `prefetch` and `prefetchRoutes` imports from `@sapper/app` should be replaced with `goto`, `preloadData` and `preloadCode` imports respectively from [`$app/navigation`](modules#$app-navigation).\n\nThe `stores` import from `@sapper/app` should be replaced \u2014 see the [Stores](migrating#pages-and-layouts-stores) section below.\n\nAny files you previously imported from directories in `src/node_modules` will need to be replaced with [`$lib`](modules#$lib) imports.\n\n### Preload\n\nAs before, pages and layouts can export a function that allows data to be loaded before rendering takes place.\n\nThis function has been renamed from `preload` to [`load`](load), it now lives in a `+page.js` (or `+layout.js`) next to its `+page.svelte` (or `+layout.svelte`), and its API has changed. Instead of two arguments \u2014 `page` and `session` \u2014 there is a single `event` argument.\n\nThere is no more `this` object, and consequently no `this.fetch`, `this.error` or `this.redirect`. Instead, you can get [`fetch`](load#making-fetch-requests) from the input methods, and both [`error`](load#errors) and [`redirect`](load#redirects) are now thrown.\n\n### Stores\n\nIn Sapper, you would get references to provided stores like so:\n\n```js\n// @filename: ambient.d.ts\ndeclare module '@sapper/app';\n\n// @filename: index.js\n// ---cut---\nimport { stores } from '@sapper/app';\nconst { preloading, page, session } = stores();\n```\n\nThe `page` store still exists; `preloading` has been replaced with a `navigating` store that contains `from` and `to` properties. `page` now has `url` and `params` properties, but no `path` or `query`.\n\nYou access them differently in SvelteKit. `stores` is now `getStores`, but in most cases it is unnecessary since you can import `navigating`, and `page` directly from [`$app/stores`](modules#$app-stores).\n\n### Routing\n\nRegex routes are no longer supported. Instead, use [advanced route matching](advanced-routing#matching).\n\n### Segments\n\nPreviously, layout components received a `segment` prop indicating the child segment. This has been removed; you should use the more flexible `$page.url.pathname` value to derive the segment you're interested in.\n\n### URLs\n\nIn Sapper, all relative URLs were resolved against the base URL \u2014 usually `/`, unless the `basepath` option was", "doc_id": "f2af6a4d-6deb-4163-bde0-36c46c8277ae", "embedding": null, "doc_hash": "bff89c297d793c2e8cb5f5cd4c68a2eb41d15995a0d37a02b260f5343565bf72", "extra_info": null, "node_info": {"start": 3215, "end": 6389, "_node_type": "1"}, "relationships": {"1": "d051101a-0d69-43f7-acdc-c836532b57ac", "2": "46093969-b21b-40f5-bf1e-e80d93ed82de", "3": "f59b7f24-5cfd-47d8-a1c2-165f27b32426"}}, "__type__": "1"}, "f59b7f24-5cfd-47d8-a1c2-165f27b32426": {"__data__": {"text": "resolved against the base URL \u2014 usually `/`, unless the `basepath` option was used \u2014 rather than against the current page.\n\nThis caused problems and is no longer the case in SvelteKit. Instead, relative URLs are resolved against the current page (or the destination page, for `fetch` URLs in `load` functions) instead. In most cases, it's easier to use root-relative (i.e. starts with `/`) URLs, since their meaning is not context-dependent.\n\n### &lt;a&gt; attributes\n\n- `sapper:prefetch` is now `data-sveltekit-preload-data`\n- `sapper:noscroll` is now `data-sveltekit-noscroll`\n\n## Endpoints\n\nIn Sapper, [server routes](routing#server) received the `req` and `res` objects exposed by Node's `http` module (or the augmented versions provided by frameworks like Polka and Express).\n\nSvelteKit is designed to be agnostic as to where the app is running \u2014 it could be running on a Node server, but could equally be running on a serverless platform or in a Cloudflare Worker. For that reason, you no longer interact directly with `req` and `res`. Your endpoints will need to be updated to match the new signature.\n\nTo support this environment-agnostic behavior, `fetch` is now available in the global context, so you don't need to import `node-fetch`, `cross-fetch`, or similar server-side fetch implementations in order to use it.\n\n## Integrations\n\nSee [the FAQ](../faq#integrations) for detailed information about integrations.\n\n### HTML minifier\n\nSapper includes `html-minifier` by default. SvelteKit does not include this, but you can add it as a prod dependency and then use it through a [hook](hooks#server-hooks-handle):\n\n```js\n// @filename: ambient.d.ts\n/// <reference types=\"@sveltejs/kit\" />\ndeclare module 'html-minifier';\n\n// @filename: index.js\n// ---cut---\nimport { minify } from 'html-minifier';\nimport { building } from '$app/environment';\n\nconst minification_options = {\n\tcollapseBooleanAttributes: true,\n\tcollapseWhitespace: true,\n\tconservativeCollapse: true,\n\tdecodeEntities: true,\n\thtml5: true,\n\tignoreCustomComments: [/^#/],\n\tminifyCSS: true,\n\tminifyJS: false,\n\tremoveAttributeQuotes: true,\n\tremoveComments: false, // some hydration code needs comments, so leave them in\n\tremoveOptionalTags: true,\n\tremoveRedundantAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tsortAttributes: true,\n\tsortClassName: true\n};\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet page = '';\n\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tpage += html;\n\t\t\tif (done) {\n\t\t\t\treturn building ? minify(page, minification_options) : page;\n\t\t\t}\n\t\t}\n\t});\n}\n```\n\nNote that `prerendering` is `false` when using `vite preview` to test the production build of the site, so to verify the results of minifying, you'll need to inspect the built HTML files directly.\n", "doc_id": "f59b7f24-5cfd-47d8-a1c2-165f27b32426", "embedding": null, "doc_hash": "45923034b7b073b2024c94ad40e6a57aea189fe2642b5b3b536e3e30c43407ed", "extra_info": null, "node_info": {"start": 6386, "end": 9253, "_node_type": "1"}, "relationships": {"1": "d051101a-0d69-43f7-acdc-c836532b57ac", "2": "f2af6a4d-6deb-4163-bde0-36c46c8277ae"}}, "__type__": "1"}, "67ac6131-905e-4d89-80c1-d39793d6d8d3": {"__data__": {"text": "---\ntitle: Routing\n---\n\nAt the heart of SvelteKit is a _filesystem-based router_. The routes of your app \u2014 i.e. the URL paths that users can access \u2014 are defined by the directories in your codebase:\n\n- `src/routes` is the root route\n- `src/routes/about` creates an `/about` route\n- `src/routes/blog/[slug]` creates a route with a _parameter_, `slug`, that can be used to load data dynamically when a user requests a page like `/blog/hello-world`\n\n> You can change `src/routes` to a different directory by editing the [project config](configuration).\n\nEach route directory contains one or more _route files_, which can be identified by their `+` prefix.\n\n## +page\n\n### +page.svelte\n\nA `+page.svelte` component defines a page of your app. By default, pages are rendered both on the server ([SSR](glossary#ssr)) for the initial request and in the browser ([CSR](glossary#csr)) for subsequent navigation.\n\n```svelte\n/// file: src/routes/+page.svelte\n<h1>Hello and welcome to my site!</h1>\n<a href=\"/about\">About my site</a>\n```\n\n```svelte\n/// file: src/routes/about/+page.svelte\n<h1>About this site</h1>\n<p>TODO...</p>\n<a href=\"/\">Home</a>\n```\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<h1>{data.title}</h1>\n<div>{@html data.content}</div>\n```\n\n> Note that SvelteKit uses `<a>` elements to navigate between routes, rather than a framework-specific `<Link>` component.\n\n### +page.js\n\nOften, a page will need to load some data before it can be rendered. For this, we add a `+page.js` module that exports a `load` function:\n\n```js\n/// file: src/routes/blog/[slug]/+page.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\tif (params.slug === 'hello-world') {\n\t\treturn {\n\t\t\ttitle: 'Hello world!',\n\t\t\tcontent: 'Welcome to our blog. Lorem ipsum dolor sit amet...'\n\t\t};\n\t}\n\n\tthrow error(404, 'Not found');\n}\n```\n\nThis function runs alongside `+page.svelte`, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See [`load`](load) for full details of the API.\n\nAs well as `load`, `+page.js` can export values that configure the page's behaviour:\n\n- `export const prerender = true` or `false` or `'auto'`\n- `export const ssr = true` or `false`\n- `export const csr = true` or `false`\n\nYou can find more information about these in [page options](page-options).\n\n### +page.server.js\n\nIf your `load` function can only run on the server \u2014 for example, if it needs to fetch data from a database or you need to access private [environment variables](modules#$env-static-private) like API keys \u2014 then you can rename `+page.js` to `+page.server.js` and change the `PageLoad` type to `PageServerLoad`.\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n\n// @filename: ambient.d.ts\ndeclare global {\n\tconst getPostFromDatabase: (slug: string) => {\n\t\ttitle:", "doc_id": "67ac6131-905e-4d89-80c1-d39793d6d8d3", "embedding": null, "doc_hash": "bdc5fbcb629ec7ca9c3624017500ec9d0de989fa065c995ded95c6da5486420b", "extra_info": null, "node_info": {"start": 0, "end": 2963, "_node_type": "1"}, "relationships": {"1": "d00bf1fb-997a-4bcf-87f5-4c068f776570", "3": "2e9795bd-da32-4dab-b8de-a8b6f4dc1530"}}, "__type__": "1"}, "2e9795bd-da32-4dab-b8de-a8b6f4dc1530": {"__data__": {"text": "getPostFromDatabase: (slug: string) => {\n\t\ttitle: string;\n\t\tcontent: string;\n\t}\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await getPostFromDatabase(params.slug);\n\n\tif (post) {\n\t\treturn post;\n\t}\n\n\tthrow error(404, 'Not found');\n}\n```\n\nDuring client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue). See [`load`](load) for full details of the API.\n\nLike `+page.js`, `+page.server.js` can export [page options](page-options) \u2014 `prerender`, `ssr` and `csr`.\n\nA `+page.server.js` file can also export _actions_. If `load` lets you read data from the server, `actions` let you write data _to_ the server using the `<form>` element. To learn how to use them, see the [form actions](form-actions) section.\n\n## +error\n\nIf an error occurs during `load`, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an `+error.svelte` file:\n\n```svelte\n/// file: src/routes/blog/[slug]/+error.svelte\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.status}: {$page.error.message}</h1>\n```\n\nSvelteKit will 'walk up the tree' looking for the closest error boundary \u2014 if the file above didn't exist it would try `src/routes/blog/+error.svelte` and then `src/routes/+error.svelte` before rendering the default error page. If _that_ fails (or if the error was thrown from the `load` function of the root `+layout`, which sits 'above' the root `+error`), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a `src/error.html` file.\n\nIf the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).\n\nIf no route can be found (404), `src/routes/+error.svelte` (or the default error page, if that file does not exist) will be used.\n\n> `+error.svelte` is _not_ used when an error occurs inside [`handle`](hooks#server-hooks-handle) or a [+server.js](#server) request handler.\n\nYou can read more about error handling [here](errors).\n\n## +layout\n\nSo far, we've treated pages as entirely standalone components \u2014 upon navigation, the existing `+page.svelte` component will be destroyed, and a new one will take its place.\n\nBut in many apps, there are elements that should be visible on _every_ page, such as top-level navigation or a footer. Instead of repeating them in every `+page.svelte`, we can put them in _layouts_.\n\n### +layout.svelte\n\nTo create a layout that applies to every page, make a file called `src/routes/+layout.svelte`. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...\n\n```html\n<slot></slot>\n```\n\n...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a `<slot>` for the page content. For example, let's add a nav bar:\n\n```html\n/// file:", "doc_id": "2e9795bd-da32-4dab-b8de-a8b6f4dc1530", "embedding": null, "doc_hash": "011d56ec20509e5f560eab082da688493c25bb796a0d09a2f6b4357cbfa2faa7", "extra_info": null, "node_info": {"start": 2919, "end": 6065, "_node_type": "1"}, "relationships": {"1": "d00bf1fb-997a-4bcf-87f5-4c068f776570", "2": "67ac6131-905e-4d89-80c1-d39793d6d8d3", "3": "5dfed96b-8e5b-4955-828c-f4c76e8156d7"}}, "__type__": "1"}, "5dfed96b-8e5b-4955-828c-f4c76e8156d7": {"__data__": {"text": "For example, let's add a nav bar:\n\n```html\n/// file: src/routes/+layout.svelte\n<nav>\n\t<a href=\"/\">Home</a>\n\t<a href=\"/about\">About</a>\n\t<a href=\"/settings\">Settings</a>\n</nav>\n\n<slot></slot>\n```\n\nIf we create pages for `/`, `/about` and `/settings`...\n\n```html\n/// file: src/routes/+page.svelte\n<h1>Home</h1>\n```\n\n```html\n/// file: src/routes/about/+page.svelte\n<h1>About</h1>\n```\n\n```html\n/// file: src/routes/settings/+page.svelte\n<h1>Settings</h1>\n```\n\n...the nav will always be visible, and clicking between the three pages will only result in the `<h1>` being replaced.\n\nLayouts can be _nested_. Suppose we don't just have a single `/settings` page, but instead have nested pages like `/settings/profile` and `/settings/notifications` with a shared submenu (for a real-life example, see [github.com/settings](https://github.com/settings)).\n\nWe can create a layout that only applies to pages below `/settings` (while inheriting the root layout with the top-level nav):\n\n```svelte\n/// file: src/routes/settings/+layout.svelte\n<script>\n\t/** @type {import('./$types').LayoutData} */\n\texport let data;\n</script>\n\n<h1>Settings</h1>\n\n<div class=\"submenu\">\n\t{#each data.sections as section}\n\t\t<a href=\"/settings/{section.slug}\">{section.title}</a>\n\t{/each}\n</div>\n\n<slot></slot>\n```\n\nBy default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, [advanced layouts](advanced-routing#advanced-layouts) can help you.\n\n### +layout.js\n\nJust like `+page.svelte` loading data from `+page.js`, your `+layout.svelte` component can get data from a [`load`](load) function in `+layout.js`.\n\n```js\n/// file: src/routes/settings/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\nIf a `+layout.js` exports [page options](page-options) \u2014 `prerender`, `ssr` and `csr` \u2014 they will be used as defaults for child pages.\n\nData returned from a layout's `load` function is also available to all its child pages:\n\n```svelte\n/// file: src/routes/settings/profile/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\tconsole.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...]\n</script>\n```\n\n> Often, layout data is unchanged when navigating between pages. SvelteKit will intelligently re-run [`load`](load) functions when necessary.\n\n### +layout.server.js\n\nTo run your layout's `load` function on the server, move it to `+layout.server.js`, and change the `LayoutLoad` type to `LayoutServerLoad`.\n\nLike `+layout.js`, `+layout.server.js` can export [page options](page-options) \u2014 `prerender`, `ssr` and `csr`.\n\n## +server\n\nAs well as pages, you can define routes with a `+server.js` file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your", "doc_id": "5dfed96b-8e5b-4955-828c-f4c76e8156d7", "embedding": null, "doc_hash": "96b3d24860be712ea796544f0915ee0a62156c17e01da659fe53d847fc9db4b2", "extra_info": null, "node_info": {"start": 6066, "end": 8995, "_node_type": "1"}, "relationships": {"1": "d00bf1fb-997a-4bcf-87f5-4c068f776570", "2": "2e9795bd-da32-4dab-b8de-a8b6f4dc1530", "3": "50305a8f-0fa2-4a8e-ad0d-48e22bacace2"}}, "__type__": "1"}, "50305a8f-0fa2-4a8e-ad0d-48e22bacace2": {"__data__": {"text": "route' or an 'endpoint'), which gives you full control over the response. Your `+server.js` file exports functions corresponding to HTTP verbs like `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, and `OPTIONS` that take a `RequestEvent` argument and return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object.\n\nFor example we could create an `/api/random-number` route with a `GET` handler:\n\n```js\n/// file: src/routes/api/random-number/+server.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\tconst max = Number(url.searchParams.get('max') ?? '1');\n\n\tconst d = max - min;\n\n\tif (isNaN(d) || d < 0) {\n\t\tthrow error(400, 'min and max must be numbers, and min must be less than max');\n\t}\n\n\tconst random = min + Math.random() * d;\n\n\treturn new Response(String(random));\n}\n```\n\nThe first argument to `Response` can be a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).\n\nYou can use the [`error`](modules#sveltejs-kit-error), [`redirect`](modules#sveltejs-kit-redirect) and [`json`](modules#sveltejs-kit-json) methods from `@sveltejs/kit` for convenience (but you don't have to).\n\nIf an error is thrown (either `throw error(...)` or an unexpected error), the response will be a JSON representation of the error or a fallback error page \u2014 which can be customised via `src/error.html` \u2014 depending on the `Accept` header. The [`+error.svelte`](#error) component will _not_ be rendered in this case. You can read more about error handling [here](errors).\n\n> When creating an `OPTIONS` handler, note that Vite will inject `Access-Control-Allow-Origin` and `Access-Control-Allow-Methods` headers \u2014 these will not be present in production unless you add them.\n\n### Receiving data\n\nBy exporting `POST`/`PUT`/`PATCH`/`DELETE`/`OPTIONS` handlers, `+server.js` files can be used to create a complete API:\n\n```svelte\n/// file: src/routes/add/+page.svelte\n<script>\n\tlet a = 0;\n\tlet b = 0;\n\tlet total = 0;\n\n\tasync function add() {\n\t\tconst response = await fetch('/api/add', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ a, b }),\n\t\t\theaders: {\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\ttotal = await response.json();\n\t}\n</script>\n\n<input type=\"number\" bind:value={a}> +\n<input type=\"number\" bind:value={b}> =\n{total}\n\n<button on:click={add}>Calculate</button>\n```\n\n```js\n/// file: src/routes/api/add/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}\n```\n\n> In general, [form actions](form-actions) are a better way to submit data from the browser to the server.\n\n### Content negotiation\n\n`+server.js` files can be placed in", "doc_id": "50305a8f-0fa2-4a8e-ad0d-48e22bacace2", "embedding": null, "doc_hash": "3daf6b72b453fdd9a9cbc1efcc396f6c1db422adbca6116ca0d790f7d3ef86e3", "extra_info": null, "node_info": {"start": 8975, "end": 11985, "_node_type": "1"}, "relationships": {"1": "d00bf1fb-997a-4bcf-87f5-4c068f776570", "2": "5dfed96b-8e5b-4955-828c-f4c76e8156d7", "3": "3158e0f6-d646-465d-b98b-72d875e6053c"}}, "__type__": "1"}, "3158e0f6-d646-465d-b98b-72d875e6053c": {"__data__": {"text": "Content negotiation\n\n`+server.js` files can be placed in the same directory as `+page` files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules:\n\n- `PUT`/`PATCH`/`DELETE`/`OPTIONS` requests are always handled by `+server.js` since they do not apply to pages\n- `GET`/`POST` requests are treated as page requests if the `accept` header prioritises `text/html` (in other words, it's a browser page request), else they are handled by `+server.js`\n\n## $types\n\nThroughout the examples above, we've been importing types from a `$types.d.ts` file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.\n\nFor example, annotating `export let data` with `PageData` (or `LayoutData`, for a `+layout.svelte` file) tells TypeScript that the type of `data` is whatever was returned from `load`:\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n```\n\nIn turn, annotating the `load` function with `PageLoad`, `PageServerLoad`, `LayoutLoad` or `LayoutServerLoad` (for `+page.js`, `+page.server.js`, `+layout.js` and `+layout.server.js` respectively) ensures that `params` and the return value are correctly typed.\n\nIf you're using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types _entirely_! Svelte's IDE tooling will insert the correct types for you, so you'll get type checking without writing them yourself. It also works with our command line tool `svelte-check`.\n\nYou can read more about omitting `$types` in our [blog post](https://svelte.dev/blog/zero-config-type-safety) about it.\n\n## Other files\n\nAny other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them.\n\nIf components and modules are needed by multiple routes, it's a good idea to put them in [`$lib`](modules#$lib).\n\n## Further reading\n\n- [Tutorial: Routing](https://learn.svelte.dev/tutorial/pages)\n- [Tutorial: API routes](https://learn.svelte.dev/tutorial/get-handlers)\n- [Docs: Advanced routing](advanced-routing)\n", "doc_id": "3158e0f6-d646-465d-b98b-72d875e6053c", "embedding": null, "doc_hash": "b697740e6a958beeb108c9f40c8281337a1a0d59d488991ff1cd314ddc9516f8", "extra_info": null, "node_info": {"start": 11995, "end": 14321, "_node_type": "1"}, "relationships": {"1": "d00bf1fb-997a-4bcf-87f5-4c068f776570", "2": "50305a8f-0fa2-4a8e-ad0d-48e22bacace2"}}, "__type__": "1"}, "42444987-2e4a-439e-aa91-bf40a882e538": {"__data__": {"text": "---\ntitle: Adapters\n---\n\nBefore you can deploy your SvelteKit app, you need to _adapt_ it for your deployment target. Adapters are small plugins that take the built app as input and generate output for deployment.\n\nOfficial adapters exist for a variety of platforms \u2014 these are documented on the following pages:\n\n- [`@sveltejs/adapter-cloudflare`](adapter-cloudflare) for Cloudflare Pages\n- [`@sveltejs/adapter-cloudflare-workers`](adapter-cloudflare-workers) for Cloudflare Workers\n- [`@sveltejs/adapter-netlify`](adapter-netlify) for Netlify\n- [`@sveltejs/adapter-node`](adapter-node) for Node servers\n- [`@sveltejs/adapter-static`](adapter-static) for static site generation (SSG)\n- [`@sveltejs/adapter-vercel`](adapter-vercel) for Vercel\n\nAdditional [community-provided adapters](https://sveltesociety.dev/components#adapters) exist for other platforms.\n\n## Using adapters\n\nYour adapter is specified in `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\n// @filename: ambient.d.ts\ndeclare module 'svelte-adapter-foo' {\n\tconst adapter: (opts: any) => import('@sveltejs/kit').Adapter;\n\texport default adapter;\n}\n\n// @filename: index.js\n// ---cut---\nimport adapter from 'svelte-adapter-foo';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// adapter options go here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Platform-specific context\n\nSome adapters may have access to additional information about the request. For example, Cloudflare Workers can access an `env` object containing KV namespaces etc. This can be passed to the `RequestEvent` used in [hooks](hooks) and [server routes](routing#server) as the `platform` property \u2014 consult each adapter's documentation to learn more.\n\n", "doc_id": "42444987-2e4a-439e-aa91-bf40a882e538", "embedding": null, "doc_hash": "c1d7e63dd21a4a388335d036d27f5e7fa27d0ff719235825040a45b3ee44ada7", "extra_info": null, "node_info": {"start": 0, "end": 1736, "_node_type": "1"}, "relationships": {"1": "9203ee87-ae02-423b-a064-5c8726add720"}}, "__type__": "1"}, "b50128db-52ab-4a47-b226-0cfa0a1742cb": {"__data__": {"text": "---\ntitle: Additional resources\n---\n\n## FAQs\n\nPlease see the [SvelteKit FAQ](../faq) for solutions to common issues and helpful tips and tricks.\n\nThe [Svelte FAQ](https://svelte.dev/faq) and [`vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md) may also be helpful for questions deriving from those libraries.\n\n## Examples\n\nWe've written and published a few different SvelteKit sites as examples:\n\n- [`sveltejs/realworld`](https://github.com/sveltejs/realworld) contains an example blog site\n- [The `sites/kit.svelte.dev` directory](https://github.com/sveltejs/kit/tree/master/sites/kit.svelte.dev) contains the code for this site\n- [`sveltejs/sites`](https://github.com/sveltejs/sites) contains the code for [svelte.dev](https://github.com/sveltejs/sites/tree/master/sites/svelte.dev) and for a [HackerNews clone](https://github.com/sveltejs/sites/tree/master/sites/hn.svelte.dev)\n\nSvelteKit users have also published plenty of examples on GitHub, under the [#sveltekit](https://github.com/topics/sveltekit) and [#sveltekit-template](https://github.com/topics/sveltekit-template) topics, as well as on [the Svelte Society site](https://sveltesociety.dev/templates#svelte-kit). Note that these have not been vetted by the maintainers and may not be up to date.\n\n## Support\n\nYou can ask for help on [Discord](https://svelte.dev/chat) and [StackOverflow](https://stackoverflow.com/questions/tagged/sveltekit). Please first search for information related to your issue in the FAQ, Google or another search engine, issue tracker, and Discord chat history in order to be respectful of others' time. There are many more people asking questions than answering them, so this will help in allowing the community to grow in a scalable fashion.\n", "doc_id": "b50128db-52ab-4a47-b226-0cfa0a1742cb", "embedding": null, "doc_hash": "f43044f98475665b2fcd6ee90dc00add33bf17fb807819c8df94c7e170ee2256", "extra_info": null, "node_info": {"start": 0, "end": 1777, "_node_type": "1"}, "relationships": {"1": "54278afd-3d98-4fd6-8d2e-fd10fdc4e124"}}, "__type__": "1"}, "810626b3-5560-44be-a316-744f640c5c78": {"__data__": {"text": "---\ntitle: Command Line Interface\n---\n\nSvelteKit projects use [Vite](https://vitejs.dev), meaning you'll mostly use its CLI (albeit via `npm run dev/build/preview` scripts):\n\n- `vite dev` \u2014 start a development server\n- `vite build` \u2014 build a production version of your app\n- `vite preview` \u2014 run the production version locally\n\nHowever SvelteKit includes its own CLI for initialising your project:\n\n## svelte-kit sync\n\n`svelte-kit sync` creates the `tsconfig.json` and all generated types (which you can import as `./$types` inside routing files) for your project. When you create a new project, it is listed as the `prepare` script and will be run automatically as part of the npm lifecycle, so you should not ordinarily have to run this command.\n", "doc_id": "810626b3-5560-44be-a316-744f640c5c78", "embedding": null, "doc_hash": "59e1623aebd38b6f89ccc6acb8a6eccbfbb7ff5d264072b632c4cf5839331044", "extra_info": null, "node_info": {"start": 0, "end": 748, "_node_type": "1"}, "relationships": {"1": "6f854dd2-b330-4761-ac10-458b1fee9c95"}}, "__type__": "1"}, "352eb31e-0842-4949-95e0-c518bf52dc09": {"__data__": {"text": "---\ntitle: Creating a project\n---\n\nThe easiest way to start building a SvelteKit app is to run `npm create`:\n\n```bash\nnpm create svelte@latest my-app\ncd my-app\nnpm install\nnpm run dev\n```\n\nThe first command will scaffold a new project in the `my-app` directory asking you if you'd like to set up some basic tooling such as TypeScript. See the FAQ for [pointers on setting up additional tooling](../faq#integrations). The subsequent commands will then install its dependencies and start a server on [localhost:5173](http://localhost:5173).\n\nThere are two basic concepts:\n\n- Each page of your app is a [Svelte](https://svelte.dev) component\n- You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user's first visit to your app is as fast as possible, then a client-side app takes over\n\nTry editing the files to get a feel for how everything works.\n\n## Editor setup\n\nWe recommend using [Visual Studio Code (aka VS Code)](https://code.visualstudio.com/download) with [the Svelte extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode), but [support also exists for numerous other editors](https://sveltesociety.dev/tools#editor-support).\n", "doc_id": "352eb31e-0842-4949-95e0-c518bf52dc09", "embedding": null, "doc_hash": "bf84ba0e8cfc60e0edd31f264572b6361a178a712aa76a48f0a92f154a63851e", "extra_info": null, "node_info": {"start": 0, "end": 1230, "_node_type": "1"}, "relationships": {"1": "054ccfb2-bafe-4095-9be9-ee8d163fee62"}}, "__type__": "1"}, "54592802-7f9f-4988-be44-664393355a5a": {"__data__": {"text": "---\ntitle: Hooks\n---\n\n'Hooks' are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework's behaviour.\n\nThere are two hooks files, both optional:\n\n- `src/hooks.server.js` \u2014 your app's server hooks\n- `src/hooks.client.js` \u2014 your app's client hooks\n\nCode in these modules will run when the application starts up, making them useful for initializing database clients and so on.\n\n> You can configure the location of these files with [`config.kit.files.hooks`](configuration#files).\n\n## Server hooks\n\nThe following hooks can be added to `src/hooks.server.js`:\n\n### handle\n\nThis function runs every time the SvelteKit server receives a [request](web-standards#fetch-apis-request) \u2014 whether that happens while the app is running, or during [prerendering](page-options#prerender) \u2014 and determines the [response](web-standards#fetch-apis-response). It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname.startsWith('/custom')) {\n\t\treturn new Response('custom response');\n\t}\n\n\tconst response = await resolve(event);\n\treturn response;\n}\n```\n\n> Requests for static assets \u2014 which includes pages that were already prerendered \u2014 are _not_ handled by SvelteKit.\n\nIf unimplemented, defaults to `({ event, resolve }) => resolve(event)`. To add custom data to the request, which is passed to handlers in `+server.js` and server `load` functions, populate the `event.locals` object, as shown below.\n\n```js\n/// file: src/hooks.server.js\n// @filename: ambient.d.ts\ntype User = {\n\tname: string;\n}\n\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: User;\n\t}\n}\n\nconst getUserInformation: (cookie: string | void) => Promise<User>;\n\n// @filename: index.js\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUserInformation(event.cookies.get('sessionid'));\n\n\tconst response = await resolve(event);\n\tresponse.headers.set('x-custom-header', 'potato');\n\n\treturn response;\n}\n```\n\nYou can define multiple `handle` functions and execute them with [the `sequence` helper function](modules#sveltejs-kit-hooks).\n\n`resolve` also supports a second, optional parameter that gives you more control over how the response will be rendered. That parameter is an object that can have the following fields:\n\n- `transformPageChunk(opts: { html: string, done: boolean }): MaybePromise<string | undefined>` \u2014 applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element's opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.\n- `filterSerializedResponseHeaders(name: string, value: string): boolean` \u2014 determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included.\n- `preload(input: { type: 'js' | 'css' | 'font' |", "doc_id": "54592802-7f9f-4988-be44-664393355a5a", "embedding": null, "doc_hash": "1c177d8da6be0ee8054b40f6f8b5ad5db852fd690a61ce78f20bd26f181c9c70", "extra_info": null, "node_info": {"start": 0, "end": 3415, "_node_type": "1"}, "relationships": {"1": "cac9584d-af43-4f7e-b3d0-e14a86bfc6c5", "3": "e5e1bad7-8ee9-4e06-b29f-3d4a88642147"}}, "__type__": "1"}, "e5e1bad7-8ee9-4e06-b29f-3d4a88642147": {"__data__": {"text": "{ type: 'js' | 'css' | 'font' | 'asset', path: string }): boolean` \u2014 determines what files should be added to the `<head>` tag to preload it. The method is called with each file that was found at build time while constructing the code chunks \u2014 so if you for example have `import './styles.css` in your `+page.svelte`, `preload` will be called with the resolved path to that CSS file when visiting that page. Note that in dev mode `preload` is _not_ called, since it depends on analysis that happens at build time. Preloading can improve performance by downloading assets sooner, but it can also hurt if too much is downloaded unnecessarily. By default, `js` and `css` files will be preloaded. `asset` files are not preloaded at all currently, but we may add this later after evaluating feedback.\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tconst response = await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('old', 'new'),\n\t\tfilterSerializedResponseHeaders: (name) => name.startsWith('x-'),\n\t\tpreload: ({ type, path }) => type === 'js' || path.includes('/important/')\n\t});\n\n\treturn response;\n}\n```\n\nNote that `resolve(...)` will never throw an error, it will always return a `Promise<Response>` with the appropriate status code. If an error is thrown elsewhere during `handle`, it is treated as fatal, and SvelteKit will respond with a JSON representation of the error or a fallback error page \u2014 which can be customised via `src/error.html` \u2014 depending on the `Accept` header. You can read more about error handling [here](errors).\n\n### handleFetch\n\nThis function allows you to modify (or replace) a `fetch` request that happens inside a `load` or `action` function that runs on the server (or during pre-rendering).\n\nFor example, your `load` function might make a request to a public URL like `https://api.yourapp.com` when the user performs a client-side navigation to the respective page, but during SSR it might make sense to hit the API directly (bypassing whatever proxies and load balancers sit between it and the public internet).\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ request, fetch }) {\n\tif (request.url.startsWith('https://api.yourapp.com/')) {\n\t\t// clone the original request, but change the URL\n\t\trequest = new Request(\n\t\t\trequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),\n\t\t\trequest\n\t\t);\n\t}\n\n\treturn fetch(request);\n}\n```\n\n**Credentials**\n\nFor same-origin requests, SvelteKit's `fetch` implementation will forward `cookie` and `authorization` headers unless the `credentials` option is set to `\"omit\"`.\n\nFor cross-origin requests, `cookie` will be included if the request URL belongs to a subdomain of the app \u2014 for example if your app is on `my-domain.com`, and your API is on `api.my-domain.com`, cookies will be included in the request.\n\nIf your app and your API are on sibling subdomains \u2014 `www.my-domain.com` and `api.my-domain.com` for example \u2014 then a cookie belonging to a common parent domain like `my-domain.com` will _not_ be included, because SvelteKit has no way to know which domain the cookie belongs to. In these cases you will need to manually include the cookie using `handleFetch`:\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2345\n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport", "doc_id": "e5e1bad7-8ee9-4e06-b29f-3d4a88642147", "embedding": null, "doc_hash": "49d226600b9f3e188c65d3c5d37fb0fee0fa3c800f7d85ce8db3c2a71be67a46", "extra_info": null, "node_info": {"start": 3392, "end": 6841, "_node_type": "1"}, "relationships": {"1": "cac9584d-af43-4f7e-b3d0-e14a86bfc6c5", "2": "54592802-7f9f-4988-be44-664393355a5a", "3": "dc814cca-4fc5-4baa-8eb8-2482b953294a"}}, "__type__": "1"}, "dc814cca-4fc5-4baa-8eb8-2482b953294a": {"__data__": {"text": "@type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ event, request, fetch }) {\n\tif (request.url.startsWith('https://api.my-domain.com/')) {\n\t\trequest.headers.set('cookie', event.request.headers.get('cookie'));\n\t}\n\n\treturn fetch(request);\n}\n```\n\n## Shared hooks\n\nThe following can be added to `src/hooks.server.js` _and_ `src/hooks.client.js`:\n\n### handleError\n\nIf an unexpected error is thrown during loading or rendering, this function will be called with the `error` and the `event`. This allows for two things:\n\n- you can log the error\n- you can generate a custom representation of the error that is safe to show to users, omitting sensitive details like messages and stack traces. The returned value becomes the value of `$page.error`. It defaults to `{ message: 'Not Found' }` in case of a 404 (you can detect them through `event.route.id` being `null`) and to `{ message: 'Internal Error' }` for everything else. To make this type-safe, you can customize the expected shape by declaring an `App.Error` interface (which must include `message: string`, to guarantee sensible fallback behavior).\n\nThe following code shows an example of typing the error shape as `{ message: string; errorId: string }` and returning it accordingly from the `handleError` functions:\n\n```ts\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tmessage: string;\n\t\t\terrorId: string;\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2322\n// @filename: ambient.d.ts\ndeclare module '@sentry/node' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/node';\nimport crypto from 'crypto';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleServerError} */\nexport async function handleError({ error, event }) {\n\tconst errorId = crypto.randomUUID();\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, { extra: { event, errorId } });\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}\n```\n\n```js\n/// file: src/hooks.client.js\n// @errors: 2322\n// @filename: ambient.d.ts\ndeclare module '@sentry/svelte' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/svelte';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleClientError} */\nexport async function handleError({ error, event }) {\n\tconst errorId = crypto.randomUUID();\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, { extra: { event, errorId } });\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}\n```\n\n> In `src/hooks.client.js`, the type of `handleError` is `HandleClientError` instead of `HandleServerError`, and `event` is a `NavigationEvent` rather than a `RequestEvent`.\n\nThis function is not called for _expected_ errors (those thrown with the [`error`](modules#sveltejs-kit-error) function imported from", "doc_id": "dc814cca-4fc5-4baa-8eb8-2482b953294a", "embedding": null, "doc_hash": "d28121191b1d39eee6a845dac45b458670f3b2bc7098daa451d060cdc44343be", "extra_info": null, "node_info": {"start": 6815, "end": 9878, "_node_type": "1"}, "relationships": {"1": "cac9584d-af43-4f7e-b3d0-e14a86bfc6c5", "2": "e5e1bad7-8ee9-4e06-b29f-3d4a88642147", "3": "c813ce0e-bcdc-4ee8-99a4-1c54edd71f25"}}, "__type__": "1"}, "c813ce0e-bcdc-4ee8-99a4-1c54edd71f25": {"__data__": {"text": "[`error`](modules#sveltejs-kit-error) function imported from `@sveltejs/kit`).\n\nDuring development, if an error occurs because of a syntax error in your Svelte code, the passed in error has a `frame` property appended highlighting the location of the error.\n\n> Make sure that `handleError` _never_ throws an error\n\n## Further reading\n\n- [Tutorial: Hooks](https://learn.svelte.dev/tutorial/handle)\n", "doc_id": "c813ce0e-bcdc-4ee8-99a4-1c54edd71f25", "embedding": null, "doc_hash": "22b58f2f54a5fa19faed6b988de8da7a2002a0d15ef192dc7ef630c15e1d722d", "extra_info": null, "node_info": {"start": 9869, "end": 10266, "_node_type": "1"}, "relationships": {"1": "cac9584d-af43-4f7e-b3d0-e14a86bfc6c5", "2": "dc814cca-4fc5-4baa-8eb8-2482b953294a"}}, "__type__": "1"}, "eb70dab8-d6a4-4e76-8e52-e6a1e93eb43c": {"__data__": {"text": "---\ntitle: Loading data\n---\n\nBefore a [`+page.svelte`](routing#page-page-svelte) component (and its containing [`+layout.svelte`](routing#layout-layout-svelte) components) can be rendered, we often need to get some data. This is done by defining `load` functions.\n\n## Page data\n\nA `+page.svelte` file can have a sibling `+page.js` that exports a `load` function, the return value of which is available to the page via the `data` prop:\n\n```js\n/// file: src/routes/blog/[slug]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\treturn {\n\t\tpost: {\n\t\t\ttitle: `Title for ${params.slug} goes here`,\n\t\t\tcontent: `Content for ${params.slug} goes here`\n\t\t}\n\t};\n}\n```\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n```\n\nThanks to the generated `$types` module, we get full type safety.\n\nA `load` function in a `+page.js` file runs both on the server and in the browser (unless combined with `export const ssr = false`, in which case it will [only run in the browser](https://kit.svelte.dev/docs/page-options#ssr)). If your `load` function should _always_ run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a `+page.server.js` instead.\n\nA more realistic version of your blog post's `load` function, that only runs on the server and pulls data from a database, might look like this:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise<{ title: string, content: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}\n```\n\nNotice that the type changed from `PageLoad` to `PageServerLoad`, because server `load` functions can access additional arguments. To understand when to use `+page.js` and when to use `+page.server.js`, see [Universal vs server](load#universal-vs-server).\n\n## Layout data\n\nYour `+layout.svelte` files can also load data, via `+layout.js` or `+layout.server.js`.\n\n```js\n/// file: src/routes/blog/[slug]/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPostSummaries(): Promise<Array<{ title: string, slug: string }>>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}\n```\n\n```svelte\n/// file: src/routes/blog/[slug]/+layout.svelte\n<script>\n\t/** @type {import('./$types').LayoutData} */\n\texport let data;\n</script>\n\n<main>\n\t<!-- +page.svelte is rendered in this <slot>", "doc_id": "eb70dab8-d6a4-4e76-8e52-e6a1e93eb43c", "embedding": null, "doc_hash": "6845550f2e1d286862b18787ffc98a4b988776ecf63a09f761f80c25bdf12dea", "extra_info": null, "node_info": {"start": 0, "end": 2966, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "3": "0022256e-98ce-4eda-98a5-1c034445e965"}}, "__type__": "1"}, "0022256e-98ce-4eda-98a5-1c034445e965": {"__data__": {"text": "+page.svelte is rendered in this <slot> -->\n\t<slot />\n</main>\n\n<aside>\n\t<h2>More posts</h2>\n\t<ul>\n\t\t{#each data.posts as post}\n\t\t\t<li>\n\t\t\t\t<a href=\"/blog/{post.slug}\">\n\t\t\t\t\t{post.title}\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</aside>\n```\n\nData returned from layout `load` functions is available to child `+layout.svelte` components and the `+page.svelte` component as well as the layout that it 'belongs' to.\n\n```diff\n/// file: src/routes/blog/[slug]/+page.svelte\n<script>\n+\timport { page } from '$app/stores';\n\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n+\t// we can access `data.posts` because it's returned from\n+\t// the parent layout `load` function\n+\t$: index = data.posts.findIndex(post => post.slug === $page.params.slug);\n+\t$: next = data.posts[index - 1];\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n+{#if next}\n+\t<p>Next post: <a href=\"/blog/{next.slug}\">{next.title}</a></p>\n+{/if}\n```\n\n> If multiple `load` functions return data with the same key, the last one 'wins' \u2014 the result of a layout `load` returning `{ a: 1, b: 2 }` and a page `load` returning `{ b: 3, c: 4 }` would be `{ a: 1, b: 3, c: 4 }`.\n\n## $page.data\n\nThe `+page.svelte` component, and each `+layout.svelte` component above it, has access to its own data plus all the data from its parents.\n\nIn some cases, we might need the opposite \u2014 a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a `title` property returned from a `load` function in `+page.js` or `+page.server.js`. This can be done with `$page.data`:\n\n```svelte\n/// file: src/routes/+layout.svelte\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<svelte:head>\n\t<title>{$page.data.title}</title>\n</svelte:head>\n```\n\nType information for `$page.data` is provided by `App.PageData`.\n\n## Universal vs server\n\nAs we've seen, there are two types of `load` function:\n\n* `+page.js` and `+layout.js` files export _universal_ `load` functions that run both on the server and in the browser\n* `+page.server.js` and `+layout.server.js` files export _server_ `load` functions that only run server-side\n\nConceptually, they're the same thing, but there are some important differences to be aware of.\n\n### When does which load function run?\n\nServer `load` functions _always_ run on the server.\n\nBy default, universal `load` functions run on the server during SSR when the user first visits your page. They will then run again during hydration, reusing any responses from [fetch requests](#making-fetch-requests). All subsequent invocations of universal `load` functions happen in the browser. You can customize the behavior through [page options](page-options). If you disable [server side rendering](page-options#ssr), you'll get an SPA and universal `load` functions _always_ run on the client.\n\nA `load` function is invoked at runtime, unless you [prerender](page-options#prerender) the page \u2014 in that case, it's invoked at", "doc_id": "0022256e-98ce-4eda-98a5-1c034445e965", "embedding": null, "doc_hash": "efb55fbccf8e1e465a045fe437c653dc67361b3b64ac9f20ed549204fdaaae9f", "extra_info": null, "node_info": {"start": 2933, "end": 5914, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "eb70dab8-d6a4-4e76-8e52-e6a1e93eb43c", "3": "c770aa7d-fcaa-4d61-bb6d-6bc93ca39124"}}, "__type__": "1"}, "c770aa7d-fcaa-4d61-bb6d-6bc93ca39124": {"__data__": {"text": "the page \u2014 in that case, it's invoked at build time.\n\n### Input\n\nBoth universal and server `load` functions have access to properties describing the request (`params`, `route` and `url`) and various functions (`fetch`, `setHeaders`, `parent` and `depends`). These are described in the following sections.\n\nServer `load` functions are called with a `ServerLoadEvent`, which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`.\n\nUniversal `load` functions are called with a `LoadEvent`, which has a `data` property. If you have `load` functions in both `+page.js` and `+page.server.js` (or `+layout.js` and `+layout.server.js`), the return value of the server `load` function is the `data` property of the universal `load` function's argument.\n\n### Output\n\nA universal `load` function can return an object containing any values, including things like custom classes and component constructors.\n\nA server `load` function must return data that can be serialized with [devalue](https://github.com/rich-harris/devalue) \u2014 anything that can be represented as JSON plus things like `BigInt`, `Date`, `Map`, `Set` and `RegExp`, or repeated/cyclical references \u2014 so that it can be transported over the network. Your data can include [promises](#streaming-with-promises), in which case it will be streamed to browsers.\n\n### When to use which\n\nServer `load` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables.\n\nUniversal `load` functions are useful when you need to `fetch` data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor.\n\nIn rare cases, you might need to use both together \u2014 for example, you might need to return an instance of a custom class that was initialised with data from your server.\n\n## Using URL data\n\nOften the `load` function depends on the URL in one way or another. For this, the `load` function provides you with `url`, `route` and `params`.\n\n### url\n\nAn instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server.\n\n> In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](adapter-node), for example, you may need to configure the adapter in order for the URL to be correct.\n\n### route\n\nContains the name of the current route directory, relative to `src/routes`:\n\n```js\n/// file: src/routes/a/[b]/[...c]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport function load({ route }) {\n\tconsole.log(route.id); // '/a/[b]/[...c]'\n}\n```\n\n### params\n\n`params` is derived from `url.pathname` and `route.id`.\n\nGiven a `route.id` of `/a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:\n\n```json\n{\n\t\"b\": \"x\",\n\t\"c\": \"y/z\"\n}\n```\n\n## Making fetch requests\n\nTo get data from an external API or a `+server.js` handler, you can use the provided `fetch` function, which behaves identically to the [native `fetch`", "doc_id": "c770aa7d-fcaa-4d61-bb6d-6bc93ca39124", "embedding": null, "doc_hash": "cc3bd35f8719c01fd58b4d928bb5025e9778ad6e54e2cff30a06eecb902de0bb", "extra_info": null, "node_info": {"start": 5917, "end": 9402, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "0022256e-98ce-4eda-98a5-1c034445e965", "3": "d2c5e0ba-093f-4e93-99d4-9acb0dfe1e68"}}, "__type__": "1"}, "d2c5e0ba-093f-4e93-99d4-9acb0dfe1e68": {"__data__": {"text": "provided `fetch` function, which behaves identically to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch) with a few additional features:\n\n- it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request\n- it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)\n- internal requests (e.g. for `+server.js` routes) go direct to the handler function when running on the server, without the overhead of an HTTP call\n- during server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](hooks#server-hooks-handle). Then, during hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you got a warning in your browser console when using the browser `fetch` instead of the `load` `fetch`, this is why.\n\n```js\n/// file: src/routes/items/[id]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\n\treturn { item };\n}\n```\n\n> Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.\n\n## Cookies and headers\n\nA server `load` function can get and set [`cookies`](types#public-types-cookies).\n\n```js\n/// file: src/routes/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\n> When setting cookies, be aware of the `path` property. By default, the `path` of a cookie is the current pathname. If you for example set a cookie at page `admin/user`, the cookie will only be available within the `admin` pages by default. In most cases you likely want to set `path` to `'/'` to make the cookie available throughout your app.\n\nBoth server and universal `load` functions have access to a `setHeaders` function that, when running on the server, can set headers for the response. (When running in the browser, `setHeaders` has no effect.) This is useful if you want the page to be cached, for example:\n\n```js\n// @errors: 2322 1360\n/// file: src/routes/products/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, setHeaders }) {\n\tconst url = `https://cms.example.com/products.json`;\n\tconst response = await fetch(url);\n\n\t// cache the page for the same length of time\n\t// as the underlying data\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nSetting the same header multiple times (even in separate `load` functions) is an error \u2014 you can only set a given header once. You cannot add a `set-cookie` header with `setHeaders` \u2014\u00a0use `cookies.set(name,", "doc_id": "d2c5e0ba-093f-4e93-99d4-9acb0dfe1e68", "embedding": null, "doc_hash": "ba7f4a3efb479d34aa6c100068a60d410a2be9451cbc345029b6c5835ed927a6", "extra_info": null, "node_info": {"start": 9369, "end": 12805, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "c770aa7d-fcaa-4d61-bb6d-6bc93ca39124", "3": "d08da341-4aaf-477a-bb4a-daf156bedf15"}}, "__type__": "1"}, "d08da341-4aaf-477a-bb4a-daf156bedf15": {"__data__": {"text": "header with `setHeaders` \u2014\u00a0use `cookies.set(name, value, options)` instead.\n\n## Using parent data\n\nOccasionally it's useful for a `load` function to access data from a parent `load` function, which can be done with `await parent()`:\n\n```js\n/// file: src/routes/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn { a: 1 };\n}\n```\n\n```js\n/// file: src/routes/abc/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n```js\n/// file: src/routes/abc/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ parent }) {\n\tconst { a, b } = await parent();\n\treturn { c: a + b };\n}\n```\n\n```svelte\n/// file: src/routes/abc/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<!-- renders `1 + 2 = 3` -->\n<p>{data.a} + {data.b} = {data.c}</p>\n```\n\n> Notice that the `load` function in `+page.js` receives the merged data from both layout `load` functions, not just the immediate parent.\n\nInside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files.\n\nIn `+page.js` or `+layout.js` it will return data from parent `+layout.js` files. However, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files that are not 'shadowed' by a `+layout.js` file\n\nTake care not to introduce waterfalls when using `await parent()`. Here, for example, `getData(params)` does not depend on the result of calling `parent()`, so we should call it first to avoid a delayed render.\n\n```diff\n/// file: +page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ params, parent }) {\n-\tconst parentData = await parent();\n\tconst data = await getData(params);\n+\tconst parentData = await parent();\n\n\treturn {\n\t\t...data\n\t\tmeta: { ...parentData.meta, ...data.meta }\n\t};\n}\n```\n\n## Errors\n\nIf an error is thrown during `load`, the nearest [`+error.svelte`](routing#error) will be rendered. For _expected_ errors, use the `error` helper from `@sveltejs/kit` to specify the HTTP status code and an optional message:\n\n```js\n/// file: src/routes/admin/+layout.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: {\n\t\t\tname: string;\n\t\t\tisAdmin: boolean;\n\t\t}\n\t}\n}\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tthrow error(401, 'not logged in');\n\t}\n\n\tif (!locals.user.isAdmin) {\n\t\tthrow error(403, 'not an admin');\n\t}\n}\n```\n\nIf an _unexpected_ error is thrown, SvelteKit will invoke [`handleError`](hooks#shared-hooks-handleerror) and treat it as a 500 Internal Error.\n\n## Redirects\n\nTo redirect users, use the `redirect`", "doc_id": "d08da341-4aaf-477a-bb4a-daf156bedf15", "embedding": null, "doc_hash": "5c524841b138249aae72aee8288917f89f6f54a18e197408bc80835da19b9f18", "extra_info": null, "node_info": {"start": 12827, "end": 15739, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "d2c5e0ba-093f-4e93-99d4-9acb0dfe1e68", "3": "0c4e7e71-8b00-425e-bd15-1db7040dec14"}}, "__type__": "1"}, "0c4e7e71-8b00-425e-bd15-1db7040dec14": {"__data__": {"text": "Redirects\n\nTo redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the location to which they should be redirected alongside a `3xx` status code.\n\n```js\n/// file: src/routes/user/+layout.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: {\n\t\t\tname: string;\n\t\t}\n\t}\n}\n\n// @filename: index.js\n// ---cut---\nimport { redirect } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tthrow redirect(307, '/login');\n\t}\n}\n```\n\n> Make sure you're not catching the thrown redirect, which would prevent SvelteKit from handling it.\n\nIn the browser, you can also navigate programmatically outside of a `load` function using [`goto`](modules#$app-navigation-goto) from [`$app.navigation`](modules#$app-navigation).\n\n## Streaming with promises\n\nPromises at the _top level_ of the returned object will be awaited, making it easy to return multiple promises without creating a waterfall. When using a server `load`, _nested_ promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available:\n\n```js\n/// file: src/routes/+page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport function load() {\n\treturn {\n\t\tone: Promise.resolve(1),\n\t\ttwo: Promise.resolve(2),\n\t\tstreamed: {\n\t\t\tthree: new Promise((fulfil) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tfulfil(3)\n\t\t\t\t}, 1000);\n\t\t\t})\n\t\t}\n\t};\n}\n```\n\nThis is useful for creating skeleton loading states, for example:\n\n```svelte\n/// file: src/routes/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<p>\n\tone: {data.one}\n</p>\n<p>\n\ttwo: {data.two}\n</p>\n<p>\n\tthree:\n\t{#await data.streamed.three}\n\t\tLoading...\n\t{:then value}\n\t\t{value}\n\t{:catch error}\n\t\t{error.message}\n\t{/await}\n</p>\n```\n\nOn platforms that do not support streaming, such as AWS Lambda, responses will be buffered. This means the page will only render once all promises resolve.\n\n> Streaming data will only work when JavaScript is enabled. You should avoid returning nested promises from a universal `load` function if the page is server rendered, as these are _not_ streamed \u2014 instead, the promise is recreated when the function re-runs in the browser.\n\n## Parallel loading\n\nWhen rendering (or navigating to) a page, SvelteKit runs all `load` functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server `load` functions are grouped into a single response. Once all `load` functions have returned, the page is rendered.\n\n## Rerunning load functions\n\nSvelteKit tracks the dependencies of each `load` function to avoid re-running it unnecessarily during navigation.\n\nFor example, given a pair of `load` functions like these...\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise<{ title: string, content: string", "doc_id": "0c4e7e71-8b00-425e-bd15-1db7040dec14", "embedding": null, "doc_hash": "7326a6a756904b0d6f229581122b549673aa51748ef38bd166e0c2db944068d3", "extra_info": null, "node_info": {"start": 15742, "end": 18827, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "d08da341-4aaf-477a-bb4a-daf156bedf15", "3": "b6cabebd-d474-4017-96d9-488d79413d48"}}, "__type__": "1"}, "b6cabebd-d474-4017-96d9-488d79413d48": {"__data__": {"text": "function getPost(slug: string): Promise<{ title: string, content: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}\n```\n\n```js\n/// file: src/routes/blog/[slug]/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPostSummaries(): Promise<Array<{ title: string, slug: string }>>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}\n```\n\n...the one in `+page.server.js` will re-run if we navigate from `/blog/trying-the-raw-meat-diet` to `/blog/i-regret-my-choices` because `params.slug` has changed. The one in `+layout.server.js` will not, because the data is still valid. In other words, we won't call `db.getPostSummaries()` a second time.\n\nA `load` function that calls `await parent()` will also re-run if a parent `load` function is re-run.\n\nDependency tracking does not apply _after_ the `load` function has returned \u2014 for example, accessing `params.x` inside a nested [promise](#streaming-with-promises) will not cause the function to re-run when `params.x` changes. (Don't worry, you'll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your `load` function.\n\n### Manual invalidation\n\nYou can also re-run `load` functions that apply to the current page using [`invalidate(url)`](modules#$app-navigation-invalidate), which re-runs all `load` functions that depend on `url`, and [`invalidateAll()`](modules#$app-navigation-invalidateall), which re-runs every `load` function. Server load functions will never automatically depend on a fetched `url` to avoid leaking secrets to the client.\n\nA `load` function depends on `url` if it calls `fetch(url)` or `depends(url)`. Note that `url` can be a custom identifier that starts with `[a-z]:`:\n\n```js\n/// file: src/routes/random-number/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, depends }) {\n\t// load reruns when `invalidate('https://api.example.com/random-number')` is called...\n\tconst response = await fetch('https://api.example.com/random-number');\n\n\t// ...or when `invalidate('app:random')` is called\n\tdepends('app:random');\n\n\treturn {\n\t\tnumber: await response.json()\n\t};\n}\n```\n\n```svelte\n/// file: src/routes/random-number/+page.svelte\n<script>\n\timport { invalidate, invalidateAll } from '$app/navigation';\n\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\tfunction rerunLoadFunction() {\n\t\t// any of these will cause the `load` function to re-run\n\t\tinvalidate('app:random');\n\t\tinvalidate('https://api.example.com/random-number');\n\t\tinvalidate(url => url.href.includes('random-number'));\n\t\tinvalidateAll();\n\t}\n</script>\n\n<p>random number: {data.number}</p>\n<button", "doc_id": "b6cabebd-d474-4017-96d9-488d79413d48", "embedding": null, "doc_hash": "ef8f8efd62f8e0346a43f5c7ada537341812d7d8d33d0bd8e1ff57773dfb563c", "extra_info": null, "node_info": {"start": 18806, "end": 21849, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "0c4e7e71-8b00-425e-bd15-1db7040dec14", "3": "646e2dde-6834-470b-85d1-6dd5cdd0f510"}}, "__type__": "1"}, "646e2dde-6834-470b-85d1-6dd5cdd0f510": {"__data__": {"text": "number: {data.number}</p>\n<button on:click={rerunLoadFunction}>Update random number</button>\n```\n\n### When do load functions re-run?\n\nTo summarize, a `load` function will re-run in the following situations:\n\n- It references a property of `params` whose value has changed\n- It references a property of `url` (such as `url.pathname` or `url.search`) whose value has changed. Properties in `request.url` are _not_ tracked\n- It calls `await parent()` and a parent `load` function re-ran\n- It declared a dependency on a specific URL via [`fetch`](#making-fetch-requests) (universal load only) or [`depends`](types#public-types-loadevent), and that URL was marked invalid with [`invalidate(url)`](modules#$app-navigation-invalidate)\n- All active `load` functions were forcibly re-run with [`invalidateAll()`](modules#$app-navigation-invalidateall)\n\n`params` and `url` can change in response to a `<a href=\"..\">` link click, a [`<form>` interaction](form-actions#get-vs-post), a [`goto`](modules#$app-navigation-goto) invocation, or a [`redirect`](modules#sveltejs-kit-redirect).\n\nNote that re-running a `load` function will update the `data` prop inside the corresponding `+layout.svelte` or `+page.svelte`; it does _not_ cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an [`afterNavigate`](modules#$app-navigation-afternavigate) callback, and/or wrap your component in a [`{#key ...}`](https://svelte.dev/docs#template-syntax-key) block.\n\n## Further reading\n\n- [Tutorial: Loading data](https://learn.svelte.dev/tutorial/page-data)\n- [Tutorial: Errors and redirects](https://learn.svelte.dev/tutorial/error-basics)\n- [Tutorial: Advanced loading](https://learn.svelte.dev/tutorial/await-parent)\n", "doc_id": "646e2dde-6834-470b-85d1-6dd5cdd0f510", "embedding": null, "doc_hash": "e334fd543fef119a788d49ed23b6a073b7efb728f821866a6fb368552069e1da", "extra_info": null, "node_info": {"start": 21881, "end": 23677, "_node_type": "1"}, "relationships": {"1": "02125823-1c45-4bcd-8e3e-40d97d648c25", "2": "b6cabebd-d474-4017-96d9-488d79413d48"}}, "__type__": "1"}, "c6458907-aca3-4e16-a22d-61772dd0e8e6": {"__data__": {"text": "---\ntitle: SEO\n---\n\nThe most important aspect of SEO is to create high-quality content that is widely linked to from around the web. However, there are a few technical considerations for building sites that rank well.\n\n## Out of the box\n\n### SSR\n\nWhile search engines have got better in recent years at indexing content that was rendered with client-side JavaScript, server-side rendered content is indexed more frequently and reliably. SvelteKit employs SSR by default, and while you can disable it in [`handle`](hooks#server-hooks-handle), you should leave it on unless you have a good reason not to.\n\n> SvelteKit's rendering is highly configurable and you can implement [dynamic rendering](https://developers.google.com/search/docs/advanced/javascript/dynamic-rendering) if necessary. It's not generally recommended, since SSR has other benefits beyond SEO.\n\n### Performance\n\nSignals such as [Core Web Vitals](https://web.dev/vitals/#core-web-vitals) impact search engine ranking. Because Svelte and SvelteKit introduce minimal overhead, it's easier to build high performance sites. You can test your site's performance using Google's [PageSpeed Insights](https://pagespeed.web.dev/) or [Lighthouse](https://developers.google.com/web/tools/lighthouse).\n\n### Normalized URLs\n\nSvelteKit redirects pathnames with trailing slashes to ones without (or vice versa depending on your [configuration](page-options#trailingslash)), as duplicate URLs are bad for SEO.\n\n## Manual setup\n\n### &lt;title&gt; and &lt;meta&gt;\n\nEvery page should have well-written and unique `<title>` and `<meta name=\"description\">` elements inside a [`<svelte:head>`](https://svelte.dev/docs#template-syntax-svelte-head). Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google's [Lighthouse SEO audits](https://web.dev/lighthouse-seo/) documentation.\n\n> A common pattern is to return SEO-related `data` from page [`load`](load) functions, then use it (as [`$page.data`](modules#$app-stores)) in a `<svelte:head>` in your root [layout](routing#layout).\n\n### Structured data\n\n[Structured data](https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data) helps search engines understand the content of a page. If you're using structured data alongside [`svelte-preprocess`](https://github.com/sveltejs/svelte-preprocess), you will need to explicitly preserve `ld+json` data (this [may change in future](https://github.com/sveltejs/svelte-preprocess/issues/305)):\n\n```js\n/// file: svelte.config.js\n// @filename: ambient.d.ts\ndeclare module 'svelte-preprocess';\n\n// @filename: index.js\n// ---cut---\nimport preprocess from 'svelte-preprocess';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tpreprocess: preprocess({\n\t\tpreserve: ['ld+json']\n\t\t// ...\n\t})\n};\n\nexport default config;\n```\n\n### Sitemaps\n\n[Sitemaps](https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap) help search engines prioritize pages within your site, particularly when you have a large amount of content. You can create a sitemap dynamically using an endpoint:\n\n```js\n/// file: src/routes/sitemap.xml/+server.js\nexport async function GET() {\n\treturn new Response(\n\t\t`\n\t\t<?xml version=\"1.0\" encoding=\"UTF-8\"", "doc_id": "c6458907-aca3-4e16-a22d-61772dd0e8e6", "embedding": null, "doc_hash": "53c622a37ee32db448de4a79c602f964456b25d7231d44b715c4c9e650265c8e", "extra_info": null, "node_info": {"start": 0, "end": 3319, "_node_type": "1"}, "relationships": {"1": "4b768329-f376-4503-973a-4c05d58fc24b", "3": "b8c40187-b311-4049-850a-e4013d585aaa"}}, "__type__": "1"}, "b8c40187-b311-4049-850a-e4013d585aaa": {"__data__": {"text": "version=\"1.0\" encoding=\"UTF-8\" ?>\n\t\t<urlset\n\t\t\txmlns=\"https://www.sitemaps.org/schemas/sitemap/0.9\"\n\t\t\txmlns:xhtml=\"https://www.w3.org/1999/xhtml\"\n\t\t\txmlns:mobile=\"https://www.google.com/schemas/sitemap-mobile/1.0\"\n\t\t\txmlns:news=\"https://www.google.com/schemas/sitemap-news/0.9\"\n\t\t\txmlns:image=\"https://www.google.com/schemas/sitemap-image/1.1\"\n\t\t\txmlns:video=\"https://www.google.com/schemas/sitemap-video/1.1\"\n\t\t>\n\t\t\t<!-- <url> elements go here -->\n\t\t</urlset>`.trim(),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/xml'\n\t\t\t}\n\t\t}\n\t);\n}\n```\n\n### AMP\n\nAn unfortunate reality of modern web development is that it is sometimes necessary to create an [Accelerated Mobile Pages (AMP)](https://amp.dev/) version of your site. In SvelteKit this can be done by setting the [`inlineStyleThreshold`](configuration#inlinestylethreshold) option...\n\n```js\n/// file: svelte.config.js\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\t// since <link rel=\"stylesheet\"> isn't\n\t\t// allowed, inline all styles\n\t\tinlineStyleThreshold: Infinity\n\t}\n};\n\nexport default config;\n```\n\n...disabling `csr` in your root `+layout.js`/`+layout.server.js`...\n\n```js\n/// file: src/routes/+layout.server.js\nexport const csr = false;\n```\n\n...and transforming the HTML using `transformPageChunk` along with `transform` imported from `@sveltejs/amp`:\n\n```js\nimport * as amp from '@sveltejs/amp';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\t\t\tif (done) return amp.transform(html);\n\t\t}\n\t});\n}\n```\n\n> It's a good idea to use the `handle` hook to validate the transformed HTML using `amphtml-validator`, but only if you're prerendering pages since it's very slow.\n", "doc_id": "b8c40187-b311-4049-850a-e4013d585aaa", "embedding": null, "doc_hash": "a4d4863d186056d6f28429931f52bb98f516ae8f9a20a041e353547ca92d56f6", "extra_info": null, "node_info": {"start": 3289, "end": 5101, "_node_type": "1"}, "relationships": {"1": "4b768329-f376-4503-973a-4c05d58fc24b", "2": "c6458907-aca3-4e16-a22d-61772dd0e8e6"}}, "__type__": "1"}, "f728d353-5d45-460e-b236-c9464ad9a5e3": {"__data__": {"text": "---\ntitle: Errors\n---\n\nErrors are an inevitable fact of software development. SvelteKit handles errors differently depending on where they occur, what kind of errors they are, and the nature of the incoming request.\n\n## Error objects\n\nSvelteKit distinguishes between expected and unexpected errors, both of which are represented as simple `{ message: string }` objects by default.\n\nYou can add additional properties, like a `code` or a tracking `id`, as shown in the examples below. (When using TypeScript this requires you to redefine the `Error` type as described in  [type safety](errors#type-safety)).\n\n## Expected errors\n\nAn _expected_ error is one created with the [`error`](modules#sveltejs-kit-error) helper imported from `@sveltejs/kit`:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise<{ title: string, content: string } | undefined>\n}\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await db.getPost(params.slug);\n\n\tif (!post) {\n\t\tthrow error(404, {\n\t\t\tmessage: 'Not found'\n\t\t});\n\t}\n\n\treturn { post };\n}\n```\n\nThis tells SvelteKit to set the response status code to 404 and render an [`+error.svelte`](routing#error) component, where `$page.error` is the object provided as the second argument to `error(...)`.\n\n```svelte\n/// file: src/routes/+error.svelte\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.error.message}</h1>\n```\n\nYou can add extra properties to the error object if needed...\n\n```diff\nthrow error(404, {\n\tmessage: 'Not found',\n+\tcode: 'NOT_FOUND'\n});\n```\n\n...otherwise, for convenience, you can pass a string as the second argument:\n\n```diff\n-throw error(404, { message: 'Not found' });\n+throw error(404, 'Not found');\n```\n\n## Unexpected errors\n\nAn _unexpected_ error is any other exception that occurs while handling a request. Since these can contain sensitive information, unexpected error messages and stack traces are not exposed to users.\n\nBy default, unexpected errors are printed to the console (or, in production, your server logs), while the error that is exposed to the user has a generic shape:\n\n```json\n{ \"message\": \"Internal Error\" }\n```\n\nUnexpected errors will go through the [`handleError`](hooks#shared-hooks-handleerror) hook, where you can add your own error handling \u2014 for example, sending errors to a reporting service, or returning a custom error object.\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2322 1360 2571 2339\n// @filename: ambient.d.ts\ndeclare module '@sentry/node' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/node';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleServerError} */\nexport function handleError({ error, event }) {\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, { extra: { event } });\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\tcode: error?.code", "doc_id": "f728d353-5d45-460e-b236-c9464ad9a5e3", "embedding": null, "doc_hash": "0de007af9943156fd13b03e5201cedc73c9f8b3ce18e26e0ab95922d2ac637ea", "extra_info": null, "node_info": {"start": 0, "end": 3220, "_node_type": "1"}, "relationships": {"1": "364739d8-0008-4e62-8007-786597604a01", "3": "f6d5c12d-7969-4901-8c34-f433d5af2f55"}}, "__type__": "1"}, "f6d5c12d-7969-4901-8c34-f433d5af2f55": {"__data__": {"text": "{\n\t\tmessage: 'Whoops!',\n\t\tcode: error?.code ?? 'UNKNOWN'\n\t};\n}\n```\n\n> Make sure that `handleError` _never_ throws an error\n\n## Responses\n\nIf an error occurs inside `handle` or inside a [`+server.js`](routing#server) request handler, SvelteKit will respond with either a fallback error page or a JSON representation of the error object, depending on the request's `Accept` headers.\n\nYou can customise the fallback error page by adding a `src/error.html` file:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title>%sveltekit.error.message%</title>\n\t</head>\n\t<body>\n\t\t<h1>My custom error page</h1>\n\t\t<p>Status: %sveltekit.status%</p>\n\t\t<p>Message: %sveltekit.error.message%</p>\n\t</body>\n</html>\n```\n\nSvelteKit will replace `%sveltekit.status%` and `%sveltekit.error.message%` with their corresponding values.\n\nIf the error instead occurs inside a `load` function while rendering a page, SvelteKit will render the [`+error.svelte`](routing#error) component nearest to where the error occurred. If the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).\n\nThe exception is when the error occurs inside the root `+layout.js` or `+layout.server.js`, since the root layout would ordinarily _contain_ the `+error.svelte` component. In this case, SvelteKit uses the fallback error page.\n\n## Type safety\n\nIf you're using TypeScript and need to customize the shape of errors, you can do so by declaring an `App.Error` interface in your app (by convention, in `src/app.d.ts`, though it can live anywhere that TypeScript can 'see'):\n\n```diff\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n+\t\t\tcode: string;\n+\t\t\tid: string;\n\t\t}\n\t}\n}\n\nexport {};\n```\n\nThis interface always includes a `message: string` property.\n\n## Further reading\n\n- [Tutorial: Errors and redirects](https://learn.svelte.dev/tutorial/error-basics)\n- [Tutorial: Hooks](https://learn.svelte.dev/tutorial/handle)\n", "doc_id": "f6d5c12d-7969-4901-8c34-f433d5af2f55", "embedding": null, "doc_hash": "11a8bc71c51c5b132c436f603e471332982521ae7e511a599a3eeba799d058d0", "extra_info": null, "node_info": {"start": 3177, "end": 5217, "_node_type": "1"}, "relationships": {"1": "364739d8-0008-4e62-8007-786597604a01", "2": "f728d353-5d45-460e-b236-c9464ad9a5e3"}}, "__type__": "1"}, "e6ee149d-a762-4442-9ff3-e979ee862d5e": {"__data__": {"text": "---\ntitle: Zero-config deployments\n---\n\nWhen you create a new SvelteKit project with `npm create svelte@latest`, it installs [`adapter-auto`](https://github.com/sveltejs/kit/tree/master/packages/adapter-auto) by default. This adapter automatically installs and uses the correct adapter for supported environments when you deploy:\n\n- [`@sveltejs/adapter-cloudflare`](adapter-cloudflare) for [Cloudflare Pages](https://developers.cloudflare.com/pages/)\n- [`@sveltejs/adapter-netlify`](adapter-netlify) for [Netlify](https://netlify.com/)\n- [`@sveltejs/adapter-vercel`](adapter-vercel) for [Vercel](https://vercel.com/)\n- [`svelte-adapter-azure-swa`](https://github.com/geoffrich/svelte-adapter-azure-swa) for [Azure Static Web Apps](https://docs.microsoft.com/en-us/azure/static-web-apps/)\n- [`svelte-kit-sst`](https://github.com/serverless-stack/sst/tree/master/packages/svelte-kit-sst) for [AWS via SST](https://docs.sst.dev/start/svelte)\n\nIt's recommended to install the appropriate adapter to your `devDependencies` once you've settled on a target environment, since this will add the adapter to your lockfile and slightly improve install times on CI.\n\n## Environment-specific configuration\n\nTo add configuration options, such as `{ edge: true }` in [`adapter-vercel`](adapter-vercel) and [`adapter-netlify`](adapter-netlify), you must install the underlying adapter \u2014 `adapter-auto` does not take any options.\n\n## Adding community adapters\n\nYou can add zero-config support for additional adapters by editing [adapters.js](https://github.com/sveltejs/kit/blob/master/packages/adapter-auto/adapters.js) and opening a pull request.", "doc_id": "e6ee149d-a762-4442-9ff3-e979ee862d5e", "embedding": null, "doc_hash": "d684b8f4eeca2a1eb8db51fe08eb5ddb25b881766e36519a8386fadee2ea5e42", "extra_info": null, "node_info": {"start": 0, "end": 1631, "_node_type": "1"}, "relationships": {"1": "024e6ac1-6875-4983-86bf-5d767369e120"}}, "__type__": "1"}, "58a7575e-062c-4d70-9610-76d73d280466": {"__data__": {"text": "---\ntitle: Form actions\n---\n\nA `+page.server.js` file can export _actions_, which allow you to `POST` data to the server using the `<form>` element.\n\nWhen using `<form>`, client-side JavaScript is optional, but you can easily _progressively enhance_ your form interactions with JavaScript to provide the best user experience.\n\n## Default actions\n\nIn the simplest case, a page declares a `default` action:\n\n```js\n/// file: src/routes/login/+page.server.js\n/** @type {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nTo invoke this action from the `/login` page, just add a `<form>` \u2014 no JavaScript needed:\n\n```svelte\n/// file: src/routes/login/+page.svelte\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\nIf someone were to click the button, the browser would send the form data via `POST` request to the server, running the default action.\n\n> Actions always use `POST` requests, since `GET` requests should never have side-effects.\n\nWe can also invoke the action from other pages (for example if there's a login widget in the nav in the root layout) by adding the `action` attribute, pointing to the page:\n\n```html\n/// file: src/routes/+layout.svelte\n<form method=\"POST\" action=\"/login\">\n\t<!-- content -->\n</form>\n```\n\n## Named actions\n\nInstead of one `default` action, a page can have as many named actions as it needs:\n\n```diff\n/// file: src/routes/login/+page.server.js\n/** @type {import('./$types').Actions} */\nexport const actions = {\n-\tdefault: async (event) => {\n+\tlogin: async (event) => {\n\t\t// TODO log the user in\n\t},\n+\tregister: async (event) => {\n+\t\t// TODO register the user\n+\t}\n};\n```\n\nTo invoke a named action, add a query parameter with the name prefixed by a `/` character:\n\n```svelte\n/// file: src/routes/login/+page.svelte\n<form method=\"POST\" action=\"?/register\">\n```\n\n```svelte\n/// file: src/routes/+layout.svelte\n<form method=\"POST\" action=\"/login?/register\">\n```\n\nAs well as the `action` attribute, we can use the `formaction` attribute on a button to `POST` the same form data to a different action than the parent `<form>`:\n\n```diff\n/// file: src/routes/login/+page.svelte\n-<form method=\"POST\">\n+<form method=\"POST\" action=\"?/login\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n+\t<button formaction=\"?/register\">Register</button>\n</form>\n```\n\n> We can't have default actions next to named actions, because if you POST to a named action without a redirect, the query parameter is persisted in the URL, which means the next default POST would go through the named action from before.\n\n## Anatomy of an action\n\nEach action receives a `RequestEvent` object, allowing you to read the data with `request.formData()`. After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the `form` property on the corresponding page and through `$page.form` app-wide until", "doc_id": "58a7575e-062c-4d70-9610-76d73d280466", "embedding": null, "doc_hash": "33923155b1387862298ffe33213503a61030a520e3711a8b227721a46febdbba", "extra_info": null, "node_info": {"start": 0, "end": 3204, "_node_type": "1"}, "relationships": {"1": "dbe78fc6-4af8-431d-8135-44a22dee0c8b", "3": "d76846f4-ba1f-4388-a912-2b179c1d6a32"}}, "__type__": "1"}, "d76846f4-ba1f-4388-a912-2b179c1d6a32": {"__data__": {"text": "property on the corresponding page and through `$page.form` app-wide until the next update.\n\n```js\n// @errors: 2304\n/// file: src/routes/login/+page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ cookies }) {\n\tconst user = await db.getUserFromSession(cookies.get('sessionid'));\n\treturn { user };\n}\n\n/** @type {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tcookies.set('sessionid', await db.createSession(user));\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};\n```\n\n```svelte\n/// file: src/routes/login/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n</script>\n\n{#if form?.success}\n\t<!-- this message is ephemeral; it exists because the page was rendered in\n\t       response to a form submission. it will vanish if the user reloads -->\n\t<p>Successfully logged in! Welcome back, {data.user.name}</p>\n{/if}\n```\n\n### Validation errors\n\nIf the request couldn't be processed because of invalid data, you can return validation errors \u2014\u00a0along with the previously submitted form values \u2014 back to the user so that they can try again. The `fail` function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through `$page.status` and the data through `form`:\n\n```diff\n/// file: src/routes/login/+page.server.js\n+import { fail } from '@sveltejs/kit';\n\n/** @type {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n+\t\tif (!email) {\n+\t\t\treturn fail(400, { email, missing: true });\n+\t\t}\n\n\t\tconst user = await db.getUser(email);\n\n+\t\tif (!user || user.password !== hash(password)) {\n+\t\t\treturn fail(400, { email, incorrect: true });\n+\t\t}\n\n\t\tcookies.set('sessionid', await db.createSession(user));\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};\n```\n\n> Note that as a precaution, we only return the email back to the page \u2014\u00a0not the password.\n\n```diff\n/// file: src/routes/login/+page.svelte\n<form method=\"POST\" action=\"?/login\">\n+\t{#if form?.missing}<p class=\"error\">The email field is required</p>{/if}\n+\t{#if form?.incorrect}<p class=\"error\">Invalid credentials!</p>{/if}\n\t<label>\n\t\tEmail\n-\t\t<input name=\"email\" type=\"email\">\n+\t\t<input name=\"email\" type=\"email\" value={form?.email ?? ''}>\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n\t<button formaction=\"?/register\">Register</button>\n</form>\n```\n\nThe returned", "doc_id": "d76846f4-ba1f-4388-a912-2b179c1d6a32", "embedding": null, "doc_hash": "39f0ff37a7ac143a14095ad4a7402faf92d3d35d41906fc410703a208d982225", "extra_info": null, "node_info": {"start": 3140, "end": 6104, "_node_type": "1"}, "relationships": {"1": "dbe78fc6-4af8-431d-8135-44a22dee0c8b", "2": "58a7575e-062c-4d70-9610-76d73d280466", "3": "e0a7b1d4-5919-49df-8220-6fd497b3a503"}}, "__type__": "1"}, "e0a7b1d4-5919-49df-8220-6fd497b3a503": {"__data__": {"text": "returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which `<form>` the returned `form` data referred to with an `id` property or similar.\n\n### Redirects\n\nRedirects (and errors) work exactly the same as in [`load`](load#redirects):\n\n```diff\n/// file: src/routes/login/+page.server.js\n+import { fail, redirect } from '@sveltejs/kit';\n\n/** @type {import('./$types').Actions} */\nexport const actions = {\n+\tlogin: async ({ cookies, request, url }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tif (!user) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}\n\n\t\tif (user.password !== hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}\n\n\t\tcookies.set('sessionid', await db.createSession(user));\n\n+\t\tif (url.searchParams.has('redirectTo')) {\n+\t\t\tthrow redirect(303, url.searchParams.get('redirectTo'));\n+\t\t}\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};\n```\n\n## Loading data\n\nAfter an action runs, the page will be re-rendered (unless a redirect or an unexpected error occurs), with the action's return value available to the page as the `form` prop. This means that your page's `load` functions will run after the action completes.\n\nNote that `handle` runs before the action is invoked, and does not re-run before the `load` functions. This means that if, for example, you use `handle` to populate `event.locals` based on a cookie, you must update `event.locals` when you set or delete the cookie in an action:\n\n```js\n/// file: src/hooks.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: {\n\t\t\tname: string;\n\t\t} | null\n\t}\n}\n\n// @filename: global.d.ts\ndeclare global {\n\tfunction getUser(sessionid: string | undefined): {\n\t\tname: string;\n\t};\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUser(event.cookies.get('sessionid'));\n\treturn resolve(event);\n}\n```\n\n```js\n/// file: src/routes/account/+page.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: {\n\t\t\tname: string;\n\t\t} | null\n\t}\n}\n\n// @filename: index.js\n// ---cut---\n/** @type {import('./$types').PageServerLoad} */\nexport function load(event) {\n\treturn {\n\t\tuser: event.locals.user\n\t};\n}\n\n/** @type {import('./$types').Actions} */\nexport const actions = {\n\tlogout: async (event) => {\n\t\tevent.cookies.delete('sessionid');\n\t\tevent.locals.user = null;\n\t}\n};\n```\n\n## Progressive enhancement\n\nIn the preceding sections we built a `/login` action that [works without client-side JavaScript](https://kryogenix.org/code/browser/everyonehasjs.html) \u2014 not a `fetch` in sight. That's great, but when JavaScript _is_ available we can", "doc_id": "e0a7b1d4-5919-49df-8220-6fd497b3a503", "embedding": null, "doc_hash": "91fcfc5b4e250a80a71a9526e6d3f2b11b0912b64b1dc0802fe6dcdb23c5ba61", "extra_info": null, "node_info": {"start": 6162, "end": 9142, "_node_type": "1"}, "relationships": {"1": "dbe78fc6-4af8-431d-8135-44a22dee0c8b", "2": "d76846f4-ba1f-4388-a912-2b179c1d6a32", "3": "6281c19c-55a9-41d3-93af-229ad650aa75"}}, "__type__": "1"}, "6281c19c-55a9-41d3-93af-229ad650aa75": {"__data__": {"text": "in sight. That's great, but when JavaScript _is_ available we can progressively enhance our form interactions to provide a better user experience.\n\n### use:enhance\n\nThe easiest way to progressively enhance a form is to add the `use:enhance` action:\n\n```diff\n/// file: src/routes/login/+page.svelte\n<script>\n+\timport { enhance } from '$app/forms';\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n</script>\n\n+<form method=\"POST\" use:enhance>\n```\n\n> Yes, it's a little confusing that the `enhance` action and `<form action>` are both called 'action'. These docs are action-packed. Sorry.\n\nWithout an argument, `use:enhance` will emulate the browser-native behaviour, just without the full-page reloads. It will:\n\n- update the `form` property, `$page.form` and `$page.status` on a successful or invalid response, but only if the action is on the same page you're submitting from. So for example if your form looks like `<form action=\"/somewhere/else\" ..>`, `form` and `$page` will _not_ be updated. This is because in the native form submission case you would be redirected to the page the action is on. If you want to have them updated either way, use [`applyAction`](#progressive-enhancement-applyaction)\n- reset the `<form>` element and invalidate all data using `invalidateAll` on a successful response\n- call `goto` on a redirect response\n- render the nearest `+error` boundary if an error occurs\n- [reset focus](accessibility#focus-management) to the appropriate element\n\nTo customise the behaviour, you can provide a `SubmitFunction` that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the `ActionResult`. Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call `update`.\n\n```svelte\n<form\n\tmethod=\"POST\"\n\tuse:enhance={({ formElement, formData, action, cancel, submitter }) => {\n\t\t// `formElement` is this `<form>` element\n\t\t// `formData` is its `FormData` object that's about to be submitted\n\t\t// `action` is the URL to which the form is posted\n\t\t// calling `cancel()` will prevent the submission\n\t\t// `submitter` is the `HTMLElement` that caused the form to be submitted\n\n\t\treturn async ({ result, update }) => {\n\t\t\t// `result` is an `ActionResult` object\n\t\t\t// `update` is a function which triggers the default logic that would be triggered if this callback wasn't set\n\t\t};\n\t}}\n>\n```\n\nYou can use these functions to show and hide loading UI, and so on.\n\n### applyAction\n\nIf you provide your own callbacks, you may need to reproduce part of the default `use:enhance` behaviour, such as showing the nearest `+error` boundary. Most of the time, calling `update` passed to the callback is enough. If you need more customization you can do so with `applyAction`:\n\n```diff\n/// file: src/routes/login/+page.svelte\n<script>\n+\timport { enhance, applyAction } from '$app/forms';\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n</script>\n\n<form\n\tmethod=\"POST\"\n\tuse:enhance={({ formElement, formData, action, cancel }) => {\n\n\t\treturn async ({ result }) => {\n\t\t\t// `result` is an `ActionResult` object\n+\t\t\tif (result.type === 'error') {\n+\t\t\t\tawait applyAction(result);\n+\t\t\t}\n\t\t};\n\t}}\n>\n```\n\nThe behaviour of `applyAction(result)` depends on `result.type`:\n\n- `success`, `failure` \u2014 sets", "doc_id": "6281c19c-55a9-41d3-93af-229ad650aa75", "embedding": null, "doc_hash": "c79eb82f3eb995006455f151706c7f78c31f07b1c449d57415f7ad58b5e1c973", "extra_info": null, "node_info": {"start": 9096, "end": 12415, "_node_type": "1"}, "relationships": {"1": "dbe78fc6-4af8-431d-8135-44a22dee0c8b", "2": "e0a7b1d4-5919-49df-8220-6fd497b3a503", "3": "ddf84ac1-8359-44b1-afc5-5e0114d1377d"}}, "__type__": "1"}, "ddf84ac1-8359-44b1-afc5-5e0114d1377d": {"__data__": {"text": "on `result.type`:\n\n- `success`, `failure` \u2014 sets `$page.status` to `result.status` and updates `form` and `$page.form` to `result.data` (regardless of where you are submitting from, in contrast to `update` from `enhance`)\n- `redirect` \u2014 calls `goto(result.location)`\n- `error` \u2014 renders the nearest `+error` boundary with `result.error`\n\nIn all cases, [focus will be reset](accessibility#focus-management).\n\n### Custom event listener\n\nWe can also implement progressive enhancement ourselves, without `use:enhance`, with a normal event listener on the `<form>`:\n\n```svelte\n/// file: src/routes/login/+page.svelte\n<script>\n\timport { invalidateAll, goto } from '$app/navigation';\n\timport { applyAction, deserialize } from '$app/forms';\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n\n\t/** @type {any} */\n\tlet error;\n\n\tasync function handleSubmit(event) {\n\t\tconst data = new FormData(this);\n\n\t\tconst response = await fetch(this.action, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: data\n\t\t});\n\n\t\t/** @type {import('@sveltejs/kit').ActionResult} */\n\t\tconst result = deserialize(await response.text());\n\n\t\tif (result.type === 'success') {\n\t\t\t// re-run all `load` functions, following the successful update\n\t\t\tawait invalidateAll();\n\t\t}\n\n\t\tapplyAction(result);\n\t}\n</script>\n\n<form method=\"POST\" on:submit|preventDefault={handleSubmit}>\n\t<!-- content -->\n</form>\n```\n\nNote that you need to `deserialize` the response before processing it further using the corresponding method from `$app/forms`. `JSON.parse()` isn't enough because form actions - like `load` functions - also support returning `Date` or `BigInt` objects.\n\nIf you have a `+server.js` alongside your `+page.server.js`, `fetch` requests will be routed there by default. To `POST` to an action in `+page.server.js` instead, use the custom `x-sveltekit-action` header:\n\n```diff\nconst response = await fetch(this.action, {\n\tmethod: 'POST',\n\tbody: data,\n+\theaders: {\n+\t\t'x-sveltekit-action': 'true'\n+\t}\n});\n```\n\n## Alternatives\n\nForm actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use [`+server.js`](routing#server) files to expose (for example) a JSON API. Here's how such an interaction could look like:\n\n```svelte\n/// file: send-message/+page.svelte\n<script>\n\tfunction rerun() {\n\t\tfetch('/api/ci', {\n\t\t\tmethod: 'POST'\n\t\t});\n\t}\n</script>\n\n<button on:click={rerun}>Rerun CI</button>\n```\n\n```js\n// @errors: 2355 1360\n/// file: api/ci/+server.js\n\n/** @type {import('./$types').RequestHandler} */\nexport function POST() {\n\t// do something\n}\n```\n\n## GET vs POST\n\nAs we've seen, to invoke a form action you must use `method=\"POST\"`.\n\nSome forms don't need to `POST` data to the server \u2014 search inputs, for example. For these you can use `method=\"GET\"` (or, equivalently, no `method` at all), and SvelteKit will treat them like `<a>` elements, using the client-side router instead of a full page navigation:\n\n```html\n<form action=\"/search\">\n\t<label>\n\t\tSearch\n\t\t<input", "doc_id": "ddf84ac1-8359-44b1-afc5-5e0114d1377d", "embedding": null, "doc_hash": "e11929a235c180b840f82eb0b43123ff7b865deff9856c450c422bdcc048797b", "extra_info": null, "node_info": {"start": 12428, "end": 15414, "_node_type": "1"}, "relationships": {"1": "dbe78fc6-4af8-431d-8135-44a22dee0c8b", "2": "6281c19c-55a9-41d3-93af-229ad650aa75", "3": "0c40755c-20f0-489f-8972-ffe818a6026f"}}, "__type__": "1"}, "0c40755c-20f0-489f-8972-ffe818a6026f": {"__data__": {"text": "action=\"/search\">\n\t<label>\n\t\tSearch\n\t\t<input name=\"q\">\n\t</label>\n</form>\n```\n\nSubmitting this form will navigate to `/search?q=...` and invoke your load function but will not invoke an action. As with `<a>` elements, you can set the [`data-sveltekit-reload`](link-options#data-sveltekit-reload), [`data-sveltekit-replacestate`](link-options#data-sveltekit-replacestate), [`data-sveltekit-keepfocus`](link-options#data-sveltekit-keepfocus) and [`data-sveltekit-noscroll`](link-options#data-sveltekit-noscroll) attributes on the `<form>` to control the router's behaviour.\n\n## Further reading\n\n- [Tutorial: Forms](https://learn.svelte.dev/tutorial/the-form-element)\n", "doc_id": "0c40755c-20f0-489f-8972-ffe818a6026f", "embedding": null, "doc_hash": "6d6ae207a733d9cd4961fb6e115dbbe167622258cdfdf7cee5ea442ab925e5f4", "extra_info": null, "node_info": {"start": 15413, "end": 16077, "_node_type": "1"}, "relationships": {"1": "dbe78fc6-4af8-431d-8135-44a22dee0c8b", "2": "ddf84ac1-8359-44b1-afc5-5e0114d1377d"}}, "__type__": "1"}, "8b9cf16b-5bf6-4492-b171-4a6d3cc5634a": {"__data__": {"text": "---\ntitle: Glossary\n---\n\nThe core of SvelteKit provides a highly configurable rendering engine. This section describes some of the terms used when discussing rendering. A reference for setting these options is provided in the documentation above.\n\n## CSR\n\nClient-side rendering (CSR) is the generation of the page contents in the web browser using JavaScript.\n\nIn SvelteKit, client-side rendering will be used by default, but you can turn off JavaScript with [the `csr = false` page option](page-options#csr).\n\n## Hydration\n\nSvelte components store some state and update the DOM when the state is updated. When fetching data during SSR, by default SvelteKit will store this data and transmit it to the client along with the server-rendered HTML. The components can then be initialized on the client with that data without having to call the same API endpoints again. Svelte will then check that the DOM is in the expected state and attach event listeners in a process called hydration. Once the components are fully hydrated, they can react to changes to their properties just like any newly created Svelte component.\n\nIn SvelteKit, pages will be hydrated by default, but you can turn off JavaScript with [the `csr = false` page option](page-options#csr).\n\n## Prerendering\n\nPrerendering means computing the contents of a page at build time and saving the HTML for display. This approach has the same benefits as traditional server-rendered pages, but avoids recomputing the page for each visitor and so scales nearly for free as the number of visitors increases. The tradeoff is that the build process is more expensive and prerendered content can only be updated by building and deploying a new version of the application.\n\nNot all pages can be prerendered. The basic rule is this: for content to be prerenderable, any two users hitting it directly must get the same content from the server, and the page must not contain [actions](form-actions). Note that you can still prerender content that is loaded based on the page's parameters as long as all users will be seeing the same prerendered content.\n\nPre-rendered pages are not limited to static content. You can build personalized pages if user-specific data is fetched and rendered client-side. This is subject to the caveat that you will experience the downsides of not doing SSR for that content as discussed above.\n\nIn SvelteKit, you can control prerendering with [the `prerender` page option](page-options#prerender) and [`prerender` config](configuration#prerender) in `svelte.config.js`.\n\n## Routing\n\nBy default, when you navigate to a new page (by clicking on a link or using the browser's forward or back buttons), SvelteKit will intercept the attempted navigation and handle it instead of allowing the browser to send a request to the server for the destination page. SvelteKit will then update the displayed contents on the client by rendering the component for the new page, which in turn can make calls to the necessary API endpoints. This process of updating the page on the client in response to attempted navigation is called client-side routing.\n\nIn SvelteKit, client-side routing will be used by default, but you can skip it with [`data-sveltekit-reload`](link-options#data-sveltekit-reload).\n\n## SPA\n\nA single-page app (SPA) is an application in which all requests to the server load a single HTML file which then does client-side rendering of the requested contents based on the requested URL. All navigation is handled on the client-side in a process called client-side routing with per-page contents being updated and common layout elements remaining largely unchanged. SPAs do not provide SSR, which has the shortcoming described above. However, some applications are not greatly impacted by these shortcomings such as a complex business application behind a login where SEO would not be important and it is known that users will be accessing the application from a consistent computing environment.\n\nIn SvelteKit, you can [build a SPA with `adapter-static`](single-page-apps).\n\n## SSG\n\nStatic Site Generation (SSG) is a term that refers to a site where every", "doc_id": "8b9cf16b-5bf6-4492-b171-4a6d3cc5634a", "embedding": null, "doc_hash": "4f88ea9bf6fd781ee7f998e09b274d8315e199b2d997313d42f9e2184f973a0f", "extra_info": null, "node_info": {"start": 0, "end": 4135, "_node_type": "1"}, "relationships": {"1": "4c4045d3-0b09-4e6a-9f2d-3b20a8e53411", "3": "b3642d3d-df0f-453c-b95e-05c2dffa59ee"}}, "__type__": "1"}, "b3642d3d-df0f-453c-b95e-05c2dffa59ee": {"__data__": {"text": "Site Generation (SSG) is a term that refers to a site where every page is prerendered. SvelteKit was not built to do only static site generation like some tools and so may not scale as well to efficiently render a very large number of pages as tools built specifically for that purpose. However, in contrast to most purpose-built SSGs, SvelteKit does nicely allow for mixing and matching different rendering types on different pages. One benefit of fully prerendering a site is that you do not need to maintain or pay for servers to perform SSR. Once generated, the site can be served from CDNs, leading to great \"time to first byte\" performance. This delivery model is often referred to as JAMstack.\n\nIn SvelteKit, you can do static site generation by using [`adapter-static`](adapter-static) or by configuring every page to be prerendered using [the `prerender` page option](page-options#prerender) or [`prerender` config](configuration#prerender) in `svelte.config.js`.\n\n## SSR\n\nServer-side rendering (SSR) is the generation of the page contents on the server. SSR is generally preferred for SEO. While some search engines can index content that is dynamically generated on the client-side it may take longer even in these cases. It also tends to improve perceived performance and makes your app accessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).\n\nIn SvelteKit, pages are server-side rendered by default. You can disable SSR with [the `ssr` page option](https://kit.svelte.dev/docs/page-options#ssr).\n", "doc_id": "b3642d3d-df0f-453c-b95e-05c2dffa59ee", "embedding": null, "doc_hash": "3d9050ef508ded5a38b02c5e517135a5affe8de5b059a31aee7ad1ca91c9d19c", "extra_info": null, "node_info": {"start": 4070, "end": 5687, "_node_type": "1"}, "relationships": {"1": "4c4045d3-0b09-4e6a-9f2d-3b20a8e53411", "2": "8b9cf16b-5bf6-4492-b171-4a6d3cc5634a"}}, "__type__": "1"}, "11f2bbbf-d12b-4c56-9213-9992d577c14a": {"__data__": {"text": "---\ntitle: Link options\n---\n\nIn SvelteKit, `<a>` elements (rather than framework-specific `<Link>` components) are used to navigate between the routes of your app. If the user clicks on a link whose `href` is 'owned' by the app (as opposed to, say, a link to an external site) then SvelteKit will navigate to the new page by importing its code and then calling any `load` functions it needs to fetch data.\n\nYou can customise the behaviour of links with `data-sveltekit-*` attributes. These can be applied to the `<a>` itself, or to a parent element.\n\nThese options also apply to `<form>` elements with [`method=\"GET\"`](form-actions#get-vs-post).\n\n## data-sveltekit-preload-data\n\nBefore the browser registers that the user has clicked on a link, we can detect that they've hovered the mouse over it (on desktop) or that a `touchstart` or `mousedown` event was triggered. In both cases, we can make an educated guess that a `click` event is coming.\n\nSvelteKit can use this information to get a head start on importing the code and fetching the page's data, which can give us an extra couple of hundred milliseconds \u2014 the difference between a user interface that feels laggy and one that feels snappy.\n\nWe can control this behaviour with the `data-sveltekit-preload-data` attribute, which can have one of two values:\n\n- `\"hover\"` means that preloading will start if the mouse comes to a rest over a link. On mobile, preloading begins on `touchstart`\n- `\"tap\"` means that preloading will start as soon as a `touchstart` or `mousedown` event is registered\n\nThe default project template has a `data-sveltekit-preload-data=\"hover\"` attribute applied to the `<body>` element in `src/app.html`, meaning that every link is preloaded on hover by default:\n\n```html\n<body data-sveltekit-preload-data=\"hover\">\n\t<div style=\"display: contents\">%sveltekit.body%</div>\n</body>\n```\n\nSometimes, calling `load` when the user hovers over a link might be undesirable, either because it's likely to result in false positives (a click needn't follow a hover) or because data is updating very quickly and a delay could mean staleness.\n\nIn these cases, you can specify the `\"tap\"` value, which causes SvelteKit to call `load` only when the user taps or clicks on a link:\n\n```html\n<a data-sveltekit-preload-data=\"tap\" href=\"/stonks\">\n\tGet current stonk values\n</a>\n```\n\n> You can also programmatically invoke `preloadData` from `$app/navigation`.\n\nData will never be preloaded if the user has chosen reduced data usage, meaning [`navigator.connection.saveData`](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) is `true`.\n\n## data-sveltekit-preload-code\n\nEven in cases where you don't want to preload _data_ for a link, it can be beneficial to preload the _code_. The `data-sveltekit-preload-code` attribute works similarly to `data-sveltekit-preload-data`, except that it can take one of four values, in decreasing 'eagerness':\n\n- `\"eager\"` means that links will be preloaded straight away\n- `\"viewport\"` means that links will be preloaded once they enter the viewport\n- `\"hover\"` - as above, except that only code is preloaded\n- `\"tap\"` - as above, except that only code is preloaded\n\nNote that `viewport` and `eager` only apply to links that are present in the DOM immediately following navigation \u2014 if a link is added later (in an `{#if ...}` block, for example) it will not be preloaded until triggered by `hover` or", "doc_id": "11f2bbbf-d12b-4c56-9213-9992d577c14a", "embedding": null, "doc_hash": "787f93f5ef18be43fe4faefbb1b66d710be74cbcdb924480631a82410d8b7ea1", "extra_info": null, "node_info": {"start": 0, "end": 3422, "_node_type": "1"}, "relationships": {"1": "91afda7e-244b-43a4-9bc0-e54bc7e5b30f", "3": "1feaf494-8818-4412-afe6-36a3da3d8e2f"}}, "__type__": "1"}, "1feaf494-8818-4412-afe6-36a3da3d8e2f": {"__data__": {"text": "block, for example) it will not be preloaded until triggered by `hover` or `tap`. This is to avoid performance pitfalls resulting from aggressively observing the DOM for changes.\n\n> Since preloading code is a prerequisite for preloading data, this attribute will only have an effect if it specifies a more eager value than any `data-sveltekit-preload-data` attribute that is present.\n\nAs with `data-sveltekit-preload-data`, this attribute will be ignored if the user has chosen reduced data usage.\n\n## data-sveltekit-reload\n\nOccasionally, we need to tell SvelteKit not to handle a link, but allow the browser to handle it. Adding a `data-sveltekit-reload` attribute to a link...\n\n```html\n<a data-sveltekit-reload href=\"/path\">Path</a>\n```\n\n...will cause a full-page navigation when the link is clicked.\n\nLinks with a `rel=\"external\"` attribute will receive the same treatment. In addition, they will be ignored during [prerendering](page-options#prerender).\n\n## data-sveltekit-replacestate\n\nSometimes you don't want navigation to create a new entry in the browser's session history. Adding a `data-sveltekit-replacestate` attribute to a link...\n\n```html\n<a data-sveltekit-replacestate href=\"/path\">Path</a>\n```\n\n...will replace the current `history` entry rather than creating a new one with `pushState` when the link is clicked.\n\n## data-sveltekit-keepfocus\n\nSometimes you don't want [focus to be reset](accessibility#focus-management) after navigation. For example, maybe you have a search form that submits as the user is typing, and you want to keep focus on the text input.  Adding a `data-sveltekit-keepfocus` attribute to it...\n\n```html\n<form data-sveltekit-keepfocus>\n\t<input type=\"text\" name=\"query\">\n</form>\n```\n\n...will cause the currently focused element to retain focus after navigation. In general, avoid using this attribute on links, since the focused element would be the `<a>` tag (and not a previously focused element) and screen reader and other assistive technology users often expect focus to be moved after a navigation. You should also only use this attribute on elements that still exist after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users.\n\n## data-sveltekit-noscroll\n\nWhen navigating to internal links, SvelteKit mirrors the browser's default navigation behaviour: it will change the scroll position to 0,0 so that the user is at the very top left of the page (unless the link includes a `#hash`, in which case it will scroll to the element with a matching ID).\n\nIn certain cases, you may wish to disable this behaviour. Adding a `data-sveltekit-noscroll` attribute to a link...\n\n```html\n<a href=\"path\" data-sveltekit-noscroll>Path</a>\n```\n\n...will prevent scrolling after the link is clicked.\n\n## Disabling options\n\nTo disable any of these options inside an element where they have been enabled, use the `\"false\"` value:\n\n```html\n<div data-sveltekit-preload-data>\n\t<!-- these links will be preloaded -->\n\t<a href=\"/a\">a</a>\n\t<a href=\"/b\">b</a>\n\t<a href=\"/c\">c</a>\n\n\t<div data-sveltekit-preload-data=\"false\">\n\t\t<!-- these links will NOT be preloaded -->\n\t\t<a href=\"/d\">d</a>\n\t\t<a href=\"/e\">e</a>\n\t\t<a href=\"/f\">f</a>\n\t</div>\n</div>\n```\n\nTo apply an attribute to an element conditionally, do this (`\"true\"` and `\"false\"` are both accepted values):\n\n```html\n<div", "doc_id": "1feaf494-8818-4412-afe6-36a3da3d8e2f", "embedding": null, "doc_hash": "916318337558c98be1bedbf2c441a9e86955773666975f907767c321fb8de087", "extra_info": null, "node_info": {"start": 3361, "end": 6743, "_node_type": "1"}, "relationships": {"1": "91afda7e-244b-43a4-9bc0-e54bc7e5b30f", "2": "11f2bbbf-d12b-4c56-9213-9992d577c14a", "3": "93dab767-f321-4b33-8def-33046c994770"}}, "__type__": "1"}, "93dab767-f321-4b33-8def-33046c994770": {"__data__": {"text": "and `\"false\"` are both accepted values):\n\n```html\n<div data-sveltekit-reload={shouldReload}>\n```", "doc_id": "93dab767-f321-4b33-8def-33046c994770", "embedding": null, "doc_hash": "dec248a85c097c652a2ddbff42a46fb4cfdf4674e11237a8079540ecace8b24a", "extra_info": null, "node_info": {"start": 6751, "end": 6847, "_node_type": "1"}, "relationships": {"1": "91afda7e-244b-43a4-9bc0-e54bc7e5b30f", "2": "1feaf494-8818-4412-afe6-36a3da3d8e2f"}}, "__type__": "1"}, "9fd61439-1513-4b66-beb4-0cd706b9964a": {"__data__": {"text": "---\ntitle: Modules\n---\n\nSvelteKit makes a number of modules available to your application.\n\n> MODULES\n", "doc_id": "9fd61439-1513-4b66-beb4-0cd706b9964a", "embedding": null, "doc_hash": "69f45c1d2e45a74b47a1db77f2af1c1005a64dfd60baed53adb3920126689191", "extra_info": null, "node_info": {"start": 0, "end": 102, "_node_type": "1"}, "relationships": {"1": "47d210da-f877-402b-af3f-0a2b5c8dd057"}}, "__type__": "1"}, "2ff95f9d-148f-4c6c-bc71-04b610129e45": {"__data__": {"text": "---\ntitle: Project structure\n---\n\nA typical SvelteKit project looks like this:\n\n```bash\nmy-project/\n\u251c src/\n\u2502 \u251c lib/\n\u2502 \u2502 \u251c server/\n\u2502 \u2502 \u2502 \u2514 [your server-only lib files]\n\u2502 \u2502 \u2514 [your lib files]\n\u2502 \u251c params/\n\u2502 \u2502 \u2514 [your param matchers]\n\u2502 \u251c routes/\n\u2502 \u2502 \u2514 [your routes]\n\u2502 \u251c app.html\n\u2502 \u251c error.html\n\u2502 \u251c hooks.client.js\n\u2502 \u2514 hooks.server.js\n\u251c static/\n\u2502 \u2514 [your static assets]\n\u251c tests/\n\u2502 \u2514 [your tests]\n\u251c package.json\n\u251c svelte.config.js\n\u251c tsconfig.json\n\u2514 vite.config.js\n```\n\nYou'll also find common files like `.gitignore` and `.npmrc` (and `.prettierrc` and `.eslintrc.cjs` and so on, if you chose those options when running `npm create svelte@latest`).\n\n## Project files\n\n### src\n\nThe `src` directory contains the meat of your project. Everything except `src/routes` and `src/app.html` is optional.\n\n- `lib` contains your library code (utilities and components), which can be imported via the [`$lib`](modules#$lib) alias, or packaged up for distribution using [`svelte-package`](packaging)\n  - `server` contains your server-only library code. It can be imported by using the [`$lib/server`](server-only-modules) alias. SvelteKit will prevent you from importing these in client code.\n- `params` contains any [param matchers](advanced-routing#matching) your app needs\n- `routes` contains the [routes](routing) of your application. You can also colocate other components that are only used within a single route here\n- `app.html` is your page template \u2014 an HTML document containing the following placeholders:\n  - `%sveltekit.head%` \u2014 `<link>` and `<script>` elements needed by the app, plus any `<svelte:head>` content\n  - `%sveltekit.body%` \u2014 the markup for a rendered page. This should live inside a `<div>` or other element, rather than directly inside `<body>`, to prevent bugs caused by browser extensions injecting elements that are then destroyed by the hydration process. SvelteKit will warn you in development if this is not the case\n  - `%sveltekit.assets%` \u2014 either [`paths.assets`](configuration#paths), if specified, or a relative path to [`paths.base`](configuration#paths)\n  - `%sveltekit.nonce%` \u2014 a [CSP](configuration#csp) nonce for manually included links and scripts, if used\n  - `%sveltekit.env.[NAME]%` - this will be replaced at render time with the `[NAME]` environment variable, which must begin with the [`publicPrefix`](configuration#env) (usually `PUBLIC_`). It will fallback to `''` if not matched.\n- `error.html` is the page that is rendered when everything else fails. It can contain the following placeholders:\n  - `%sveltekit.status%` \u2014 the HTTP status\n  - `%sveltekit.error.message%` \u2014 the error message\n- `hooks.client.js` contains your client [hooks](hooks)\n- `hooks.server.js` contains your server [hooks](hooks)\n- `service-worker.js` contains your [service worker](service-workers)\n\n(Whether the project contains `.js` or `.ts` files depends on whether you opt to use TypeScript when you create your project. You can switch between JavaScript and TypeScript in the documentation using the toggle at the bottom of this page.)\n\nIf you added [Vitest](https://vitest.dev) when", "doc_id": "2ff95f9d-148f-4c6c-bc71-04b610129e45", "embedding": null, "doc_hash": "7bf793b7ed187ac8b8358a2f29fa5946a16e09d32f8a539e153b381adb63b318", "extra_info": null, "node_info": {"start": 0, "end": 3099, "_node_type": "1"}, "relationships": {"1": "ce4218e0-7d23-45e1-a8a1-1a566716a547", "3": "40a247f5-831b-4436-be76-20c49b3416d1"}}, "__type__": "1"}, "40a247f5-831b-4436-be76-20c49b3416d1": {"__data__": {"text": "you added [Vitest](https://vitest.dev) when you set up your project, your unit tests will live in the `src` directory with a `.test.js` extension.\n\n### static\n\nAny static assets that should be served as-is, like `robots.txt` or `favicon.png`, go in here.\n\n### tests\n\nIf you added [Playwright](https://playwright.dev/) for browser testing when you set up your project, the tests will live in this directory.\n\n### package.json\n\nYour `package.json` file must include `@sveltejs/kit`, `svelte` and `vite` as `devDependencies`.\n\nWhen you create a project with `npm create svelte@latest`, you'll also notice that `package.json` includes `\"type\": \"module\"`. This means that `.js` files are interpreted as native JavaScript modules with `import` and `export` keywords. Legacy CommonJS files need a `.cjs` file extension.\n\n### svelte.config.js\n\nThis file contains your Svelte and SvelteKit [configuration](configuration).\n\n### tsconfig.json\n\nThis file (or `jsconfig.json`, if you prefer type-checked `.js` files over `.ts` files) configures TypeScript, if you added typechecking during `npm create svelte@latest`. Since SvelteKit relies on certain configuration being set a specific way, it generates its own `.svelte-kit/tsconfig.json` file which your own config `extends`.\n\n### vite.config.js\n\nA SvelteKit project is really just a [Vite](https://vitejs.dev) project that uses the [`@sveltejs/kit/vite`](modules#sveltejs-kit-vite) plugin, along with any other [Vite configuration](https://vitejs.dev/config/).\n\n## Other files\n\n### .svelte-kit\n\nAs you develop and build your project, SvelteKit will generate files in a `.svelte-kit` directory (configurable as [`outDir`](configuration#outdir)). You can ignore its contents, and delete them at any time (they will be regenerated when you next `dev` or `build`).\n", "doc_id": "40a247f5-831b-4436-be76-20c49b3416d1", "embedding": null, "doc_hash": "9782579d64a656d5836ac835dceee1bd99bd5da449585b8bc98e7fa11a8525b0", "extra_info": null, "node_info": {"start": 3056, "end": 4858, "_node_type": "1"}, "relationships": {"1": "ce4218e0-7d23-45e1-a8a1-1a566716a547", "2": "2ff95f9d-148f-4c6c-bc71-04b610129e45"}}, "__type__": "1"}, "8b0e5284-fc8a-45a6-8002-7b0f74760f5d": {"__data__": {"text": "---\ntitle: Node servers\n---\n\nTo generate a standalone Node server, use [`adapter-node`](https://github.com/sveltejs/kit/tree/master/packages/adapter-node).\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-node`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-node';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Deploying\n\nFirst, build your app with `npm run build`. This will create the production server in the output directory specified in the adapter options, defaulting to `build`.\n\nYou will need the output directory, the project's `package.json`, and the production dependencies in `node_modules` to run the application. Production dependencies can be generated by copying the `package.json` and `package-lock.json` and then running `npm ci --omit dev` (you can skip this step if your app doesn't have any dependencies). You can then start your app with this command:\n\n```bash\nnode build\n```\n\nDevelopment dependencies will be bundled into your app using [Rollup](https://rollupjs.org). To control whether a given package is bundled or externalised, place it in `devDependencies` or `dependencies` respectively in your `package.json`.\n\n## Environment variables\n\nIn `dev` and `preview`, SvelteKit will read environment variables from your `.env` file (or `.env.local`, or `.env.[mode]`, [as determined by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files).)\n\nIn production, `.env` files are _not_ automatically loaded. To do so, install `dotenv` in your project...\n\n```bash\nnpm install dotenv\n```\n\n...and invoke it before running the built app:\n\n```diff\n-node build\n+node -r dotenv/config build\n```\n\n### `PORT` and `HOST`\n\nBy default, the server will accept connections on `0.0.0.0` using port 3000. These can be customised with the `PORT` and `HOST` environment variables:\n\n```\nHOST=127.0.0.1 PORT=4000 node build\n```\n\n### `ORIGIN`, `PROTOCOL_HEADER` and `HOST_HEADER`\n\nHTTP doesn't give SvelteKit a reliable way to know the URL that is currently being requested. The simplest way to tell SvelteKit where the app is being served is to set the `ORIGIN` environment variable:\n\n```\nORIGIN=https://my.site node build\n\n# or e.g. for local previewing and testing\nORIGIN=http://localhost:3000 node build\n```\n\nWith this, a request for the `/stuff` pathname will correctly resolve to `https://my.site/stuff`. Alternatively, you can specify headers that tell SvelteKit about the request protocol and host, from which it can construct the origin URL:\n\n```\nPROTOCOL_HEADER=x-forwarded-proto HOST_HEADER=x-forwarded-host node build\n```\n\n> [`x-forwarded-proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`x-forwarded-host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) are de facto standard headers that forward the original protocol and host if you're using a reverse proxy (think load balancers and CDNs). You should only set these variables if your server is behind a trusted reverse proxy; otherwise, it'd be possible for clients to spoof these headers.\n\nIf `adapter-node` can't correctly determine the URL of your deployment, you may experience this error when using [form actions](form-actions):\n\n>", "doc_id": "8b0e5284-fc8a-45a6-8002-7b0f74760f5d", "embedding": null, "doc_hash": "1b6b4966713d1bcdee81230b415b2094d21e2f24c0ef3b3cfdadcb02757df585", "extra_info": null, "node_info": {"start": 0, "end": 3286, "_node_type": "1"}, "relationships": {"1": "ad537e54-06f5-4c57-87b6-d73e1c967e57", "3": "00fa9e5a-ff82-487e-b3a8-b5db3cbd5899"}}, "__type__": "1"}, "00fa9e5a-ff82-487e-b3a8-b5db3cbd5899": {"__data__": {"text": "you may experience this error when using [form actions](form-actions):\n\n> Cross-site POST form submissions are forbidden\n\n### `ADDRESS_HEADER` and `XFF_DEPTH`\n\nThe [RequestEvent](types#public-types-requestevent) object passed to hooks and endpoints includes an `event.getClientAddress()` function that returns the client's IP address. By default this is the connecting `remoteAddress`. If your server is behind one or more proxies (such as a load balancer), this value will contain the innermost proxy's IP address rather than the client's, so we need to specify an `ADDRESS_HEADER` to read the address from:\n\n```\nADDRESS_HEADER=True-Client-IP node build\n```\n\n> Headers can easily be spoofed. As with `PROTOCOL_HEADER` and `HOST_HEADER`, you should [know what you're doing](https://adam-p.ca/blog/2022/03/x-forwarded-for/) before setting these.\n\nIf the `ADDRESS_HEADER` is `X-Forwarded-For`, the header value will contain a comma-separated list of IP addresses. The `XFF_DEPTH` environment variable should specify how many trusted proxies sit in front of your server. E.g. if there are three trusted proxies, proxy 3 will forward the addresses of the original connection and the first two proxies:\n\n```\n<client address>, <proxy 1 address>, <proxy 2 address>\n```\n\nSome guides will tell you to read the left-most address, but this leaves you [vulnerable to spoofing](https://adam-p.ca/blog/2022/03/x-forwarded-for/):\n\n```\n<spoofed address>, <client address>, <proxy 1 address>, <proxy 2 address>\n```\n\nWe instead read from the _right_, accounting for the number of trusted proxies. In this case, we would use `XFF_DEPTH=3`.\n\n> If you need to read the left-most address instead (and don't care about spoofing) \u2014 for example, to offer a geolocation service, where it's more important for the IP address to be _real_ than _trusted_, you can do so by inspecting the `x-forwarded-for` header within your app.\n\n### `BODY_SIZE_LIMIT`\n\nThe maximum request body size to accept in bytes including while streaming. Defaults to 512kb. You can disable this option with a value of 0 and implement a custom check in [`handle`](hooks#server-hooks-handle) if you need something more advanced.\n\n## Options\n\nThe adapter can be configured with various options:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-node';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown\n\t\t\tout: 'build',\n\t\t\tprecompress: false,\n\t\t\tenvPrefix: '',\n\t\t\tpolyfill: true\n\t\t})\n\t}\n};\n```\n\n### out\n\nThe directory to build the server to. It defaults to `build` \u2014 i.e. `node build` would start the server locally after it has been created.\n\n### precompress\n\nEnables precompressing using gzip and brotli for assets and prerendered pages. It defaults to `false`.\n\n### envPrefix\n\nIf you need to change the name of the environment variables used to configure the deployment (for example, to deconflict with environment variables you don't control), you can specify a prefix:\n\n```js\nenvPrefix: 'MY_CUSTOM_';\n```\n\n```sh\nMY_CUSTOM_HOST=127.0.0.1 \\\nMY_CUSTOM_PORT=4000 \\\nMY_CUSTOM_ORIGIN=https://my.site \\\nnode build\n```\n\n### polyfill\n\nControls whether your build will load polyfills for missing modules. It defaults to `true`, and should only be disabled when using Node", "doc_id": "00fa9e5a-ff82-487e-b3a8-b5db3cbd5899", "embedding": null, "doc_hash": "b4d9b954b928035054dbbd717109e0c68ab4dad53af145b0a5529115bc3726d8", "extra_info": null, "node_info": {"start": 3222, "end": 6499, "_node_type": "1"}, "relationships": {"1": "ad537e54-06f5-4c57-87b6-d73e1c967e57", "2": "8b0e5284-fc8a-45a6-8002-7b0f74760f5d", "3": "91685a13-5134-413e-9148-b12a6ca02f40"}}, "__type__": "1"}, "91685a13-5134-413e-9148-b12a6ca02f40": {"__data__": {"text": "for missing modules. It defaults to `true`, and should only be disabled when using Node 18.11 or greater.\n\nNote: to use Node's built-in `crypto` global with Node 18 you will need to use the `--experimental-global-webcrypto` flag. This flag is not required with Node 20.\n\n## Custom server\n\nThe adapter creates two files in your build directory \u2014 `index.js` and `handler.js`. Running `index.js` \u2014 e.g. `node build`, if you use the default build directory \u2014 will start a server on the configured port.\n\nAlternatively, you can import the `handler.js` file, which exports a handler suitable for use with [Express](https://github.com/expressjs/expressjs.com), [Connect](https://github.com/senchalabs/connect) or [Polka](https://github.com/lukeed/polka) (or even just the built-in [`http.createServer`](https://nodejs.org/dist/latest/docs/api/http.html#httpcreateserveroptions-requestlistener)) and set up your own server:\n\n```js\n// @errors: 2307 7006\n/// file: my-server.js\nimport { handler } from './build/handler.js';\nimport express from 'express';\n\nconst app = express();\n\n// add a route that lives separately from the SvelteKit app\napp.get('/healthcheck', (req, res) => {\n\tres.end('ok');\n});\n\n// let SvelteKit handle everything else, including serving prerendered pages and static assets\napp.use(handler);\n\napp.listen(3000, () => {\n\tconsole.log('listening on port 3000');\n});\n```\n\n## Troubleshooting\n\n### Is there a hook for cleaning up before the server exits?\n\nThere's nothing built-in to SvelteKit for this, because such a cleanup hook depends highly on the execution environment you're on. For Node, you can use its built-in `process.on(..)` to implement a callback that runs before the server exits:\n\n```js\n// @errors: 2304 2580\nfunction shutdownGracefully() {\n\t// anything you need to clean up manually goes in here\n\tdb.shutdown();\n}\n\nprocess.on('SIGINT', shutdownGracefully);\nprocess.on('SIGTERM', shutdownGracefully);\n```\n", "doc_id": "91685a13-5134-413e-9148-b12a6ca02f40", "embedding": null, "doc_hash": "4f9a352dccf42be1305e1962a204b8f991c4ebaa79ff1ac9a1a4a3f5fe39e818", "extra_info": null, "node_info": {"start": 6477, "end": 8405, "_node_type": "1"}, "relationships": {"1": "ad537e54-06f5-4c57-87b6-d73e1c967e57", "2": "00fa9e5a-ff82-487e-b3a8-b5db3cbd5899"}}, "__type__": "1"}, "4bbf861f-f3a0-4d89-a549-d48224ace0be": {"__data__": {"text": "---\ntitle: Page options\n---\n\nBy default, SvelteKit will render (or [prerender](glossary#prerendering)) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called [**hydration**](glossary#hydration). For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a [**router**](routing) that takes over subsequent navigations.\n\nYou can control each of these on a page-by-page basis by exporting options from [`+page.js`](routing#page-page-js) or [`+page.server.js`](routing#page-page-server-js), or for groups of pages using a shared [`+layout.js`](routing#layout-layout-js) or [`+layout.server.js`](routing#layout-layout-server-js). To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so \u2014 for example \u2014 you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.\n\nYou can mix and match these options in different areas of your app. For example you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile.\n\n## prerender\n\nIt's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be [_prerendered_](glossary#prerendering).\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = true;\n```\n\nAlternatively, you can set `export const prerender = true` in your root `+layout.js` or `+layout.server.js` and prerender everything except pages that are explicitly marked as _not_ prerenderable:\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = false;\n```\n\nRoutes with `prerender = true` will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like `/blog/[slug]` where you want to prerender your most recent/popular content but server-render the long tail) \u2014 for these cases, there's a third option, 'auto':\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = 'auto';\n```\n\n> If your entire app is suitable for prerendering, you can use [`adapter-static`](https://github.com/sveltejs/kit/tree/master/packages/adapter-static), which will output files suitable for use with any static webserver.\n\nThe prerenderer will start at the root of your app and generate files for any prerenderable pages or `+server.js` routes it finds. Each page is scanned for `<a>` elements that point to other pages that are candidates for prerendering \u2014 because of this, you generally don't need to specify which pages should be accessed. If you _do_ need to specify which pages should be accessed by the prerenderer, you can do so with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an [`entries`](#entries) function from your dynamic route.\n\nWhile prerendering, the value of `building` imported from [`$app/environment`](modules#$app-environment) will be `true`.\n\n### Prerendering server routes\n\nUnlike the other page options, `prerender` also applies to `+server.js` files. These files are _not_ affected from layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a `+page.js` contains this `load`", "doc_id": "4bbf861f-f3a0-4d89-a549-d48224ace0be", "embedding": null, "doc_hash": "9cd4b42ea99e5e7620af35b1fe3409851023592308e854bd2062cb49b7f08009", "extra_info": null, "node_info": {"start": 0, "end": 3625, "_node_type": "1"}, "relationships": {"1": "990479c0-082d-4190-b77b-2dfe03fa148f", "3": "5830c0ad-c9bf-405c-a751-aa69c3e847eb"}}, "__type__": "1"}, "5830c0ad-c9bf-405c-a751-aa69c3e847eb": {"__data__": {"text": "if any. For example if a `+page.js` contains this `load` function...\n\n```js\n/// file: +page.js\nexport const prerender = true;\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst res = await fetch('/my-server-route.json');\n\treturn await res.json();\n}\n```\n\n...then `src/routes/my-server-route.json/+server.js` will be treated as prerenderable if it doesn't contain its own `export const prerender = false`.\n\n### When not to prerender\n\nThe basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server.\n\n> Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in `onMount` in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators.\n\nNote that you can still prerender pages that load data based on the page's parameters, such as a `src/routes/blog/[slug]/+page.svelte` route.\n\nAccessing [`url.searchParams`](load#using-url-data-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in `onMount`).\n\nPages with [actions](form-actions) cannot be prerendered, because a server must be able to handle the action `POST` requests.\n\n### Prerender and ssr\n\nIf you set the [ssr option](#ssr) to `false`, each request will result in the same empty HTML shell. Since this would result in unnecessary work, SvelteKit defaults to prerendering any pages it finds where `prerender` is not explicitly set to `false`.\n\n### Route conflicts\n\nBecause prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, `src/routes/foo/+server.js` and `src/routes/foo/bar/+server.js` would try to create `foo` and `foo/bar`, which is impossible.\n\nFor that reason among others, it's recommended that you always include a file extension \u2014 `src/routes/foo.json/+server.js` and `src/routes/foo/bar.json/+server.js` would result in `foo.json` and `foo/bar.json` files living harmoniously side-by-side.\n\nFor _pages_, we skirt around this problem by writing `foo/index.html` instead of `foo`.\n\n### Troubleshooting\n\nIf you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has `export const prerender = true` but the page wasn't actually prerendered, because it wasn't reached by the prerendering crawler.\n\nSince these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are two ways to fix it:\n\n* Ensure that SvelteKit can find the route by following links from [`config.kit.prerender.entries`](configuration#prerender) or the [`entries`](#entries) page option. Add links to dynamic routes (i.e. pages with `[parameters]` ) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn't know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable.\n* Change `export const prerender = true` to `export const prerender = 'auto'`. Routes with `'auto'` can be dynamically server rendered\n\n## entries\n\nSvelteKit will discover pages to prerender automatically, by starting at _entry points_ and crawling them. By", "doc_id": "5830c0ad-c9bf-405c-a751-aa69c3e847eb", "embedding": null, "doc_hash": "271a1c67ed0295127384839d155edcdedde3db63b09d798992a01863139bd22a", "extra_info": null, "node_info": {"start": 3579, "end": 7176, "_node_type": "1"}, "relationships": {"1": "990479c0-082d-4190-b77b-2dfe03fa148f", "2": "4bbf861f-f3a0-4d89-a549-d48224ace0be", "3": "732e8ffe-c6ca-4f60-a322-e56f74293d96"}}, "__type__": "1"}, "732e8ffe-c6ca-4f60-a322-e56f74293d96": {"__data__": {"text": "to prerender automatically, by starting at _entry points_ and crawling them. By default, all your non-dynamic routes are considered entry points \u2014 for example, if you have these routes...\n\n```bash\n/             # non-dynamic\n/blog         # non-dynamic\n/blog/[slug]  # dynamic, because of `[slug]`\n```\n\n...SvelteKit will prerender `/` and `/blog`, and in the process discover links like `<a href=\"/blog/hello-world\">` which give it new pages to prerender.\n\nMost of the time, that's enough. In some situations, links to pages like `/blog/hello-world` might not exist (or might not exist on prerendered pages), in which case we need to tell SvelteKit about their existence.\n\nThis can be done with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an `entries` function from a `+page.js`, a `+page.server.js` or a `+server.js` belonging to a dynamic route:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n/** @type {import('./$types').EntryGenerator} */\nexport function entries() {\n\treturn [\n\t\t{ slug: 'hello-world' },\n\t\t{ slug: 'another-blog-post' }\n\t];\n}\n\nexport const prerender = true;\n```\n\n`entries` can be an `async` function, allowing you to (for example) retrieve a list of posts from a CMS or database, in the example above.\n\n## ssr\n\nNormally, SvelteKit renders your page on the server first and sends that HTML to the client where it's [hydrated](glossary#hydration). If you set `ssr` to `false`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document` for example), but in most situations it's not recommended ([see appendix](glossary#ssr)).\n\n```js\n/// file: +page.js\nexport const ssr = false;\n```\n\nIf you add `export const ssr = false` to your root `+layout.js`, your entire app will only be rendered on the client \u2014 which essentially means you turn your app into an SPA.\n\n## csr\n\nOrdinarily, SvelteKit [hydrates](glossary#hydration) your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all \u2014 many blog posts and 'about' pages fall into this category. In these cases you can disable CSR:\n\n```js\n/// file: +page.js\nexport const csr = false;\n```\n\n> If both `ssr` and `csr` are `false`, nothing will be rendered!\n\n## trailingSlash\n\nBy default, SvelteKit will remove trailing slashes from URLs \u2014 if you visit `/about/`, it will respond with a redirect to `/about`. You can change this behaviour with the `trailingSlash` option, which can be one of `'never'` (the default), `'always'`, or `'ignore'`.\n\nAs with other page options, you can export this value from a `+layout.js` or a `+layout.server.js` and it will apply to all child pages. You can also export the configuration from `+server.js` files.\n\n```js\n/// file: src/routes/+layout.js\nexport const trailingSlash = 'always';\n```\n\nThis option also affects [prerendering](#prerender). If `trailingSlash` is `always`, a route like `/about` will result in an `about/index.html` file, otherwise it will create `about.html`, mirroring static webserver conventions.\n\n> Ignoring trailing slashes is not recommended \u2014 the semantics of relative paths differ between the two cases (`./y` from `/x` is", "doc_id": "732e8ffe-c6ca-4f60-a322-e56f74293d96", "embedding": null, "doc_hash": "184c875066e27ced58dbd299bf3f2c5885b75273613165e9f89e3dd6a9673fd6", "extra_info": null, "node_info": {"start": 7156, "end": 10408, "_node_type": "1"}, "relationships": {"1": "990479c0-082d-4190-b77b-2dfe03fa148f", "2": "5830c0ad-c9bf-405c-a751-aa69c3e847eb", "3": "b574f218-fb6b-4cf4-ba42-39a894c6af2a"}}, "__type__": "1"}, "b574f218-fb6b-4cf4-ba42-39a894c6af2a": {"__data__": {"text": "relative paths differ between the two cases (`./y` from `/x` is `/y`, but from `/x/` is `/x/y`), and `/x` and `/x/` are treated as separate URLs which is harmful to SEO.\n\n## config\n\nWith the concept of [adapters](adapters), SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment \u2014 for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments.\n\n`config` is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you're using. Every adapter should provide a `Config` interface to import for type safety. Consult the documentation of your adapter for more information.\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'some-adapter' {\n\texport interface Config { runtime: string }\n}\n\n// @filename: index.js\n// ---cut---\n/// file: src/routes/+page.js\n/** @type {import('some-adapter').Config} */\nexport const config = {\n\truntime: 'edge'\n};\n```\n\n`config` objects are merged at the top level (but _not_ deeper levels). This means you don't need to repeat all the values in a `+page.js` if you want to only override some of the values in the upper `+layout.js`. For example this layout configuration...\n\n```js\n/// file: src/routes/+layout.js\nexport const config = {\n\truntime: 'edge',\n\tregions: 'all',\n\tfoo: {\n\t\tbar: true\n\t}\n}\n```\n\n...is overridden by this page configuration...\n\n```js\n/// file: src/routes/+page.js\nexport const config = {\n\tregions: ['us1', 'us2'],\n\tfoo: {\n\t\tbaz: true\n\t}\n}\n```\n\n...which results in the config value `{ runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } }` for that page.\n\n## Further reading\n\n- [Tutorial: Page options](https://learn.svelte.dev/tutorial/page-options)\n", "doc_id": "b574f218-fb6b-4cf4-ba42-39a894c6af2a", "embedding": null, "doc_hash": "eb256ad64e26d5a6b373ce5e1fa5eaf3545fb5ed0edcd89e3963f6dc6e1813b1", "extra_info": null, "node_info": {"start": 10413, "end": 12207, "_node_type": "1"}, "relationships": {"1": "990479c0-082d-4190-b77b-2dfe03fa148f", "2": "732e8ffe-c6ca-4f60-a322-e56f74293d96"}}, "__type__": "1"}, "5ed23912-cad5-4091-ab7d-ad1bc537457a": {"__data__": {"text": "---\ntitle: Service workers\n---\n\nService workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don't need offline support (or can't realistically implement it because of the type of app you're building), it's often worth using service workers to speed up navigation by precaching your built JS and CSS.\n\nIn SvelteKit, if you have a `src/service-worker.js` file (or `src/service-worker/index.js`) it will be bundled and automatically registered. You can change the [location of your service worker](configuration#files) if you need to.\n\nYou can [disable automatic registration](configuration#serviceworker) if you need to register the service worker with your own logic or use another solution. The default registration looks something like this:\n\n```js\nif ('serviceWorker' in navigator) {\n\taddEventListener('load', function () {\n\t\tnavigator.serviceWorker.register('./path/to/service-worker.js');\n\t});\n}\n```\n\n## Inside the service worker\n\nInside the service worker you have access to the [`$service-worker` module](modules#$service-worker), which provides you with the paths to all static assets, build files and prerendered pages. You're also provided with an app version string, which you can use for creating a unique cache name, and the deployment's `base` path. If your Vite config specifies `define` (used for global variable replacements), this will be applied to service workers as well as your server/client builds.\n\nThe following example caches the built app and any files in `static` eagerly, and caches all other requests as they happen. This would make each page work offline once visited.\n\n```js\n// @errors: 2339\n/// <reference types=\"@sveltejs/kit\" />\nimport { build, files, version } from '$service-worker';\n\n// Create a unique cache name for this deployment\nconst CACHE = `cache-${version}`;\n\nconst ASSETS = [\n\t...build, // the app itself\n\t...files  // everything in `static`\n];\n\nself.addEventListener('install', (event) => {\n\t// Create a new cache and add all files to it\n\tasync function addFilesToCache() {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t}\n\n\tevent.waitUntil(addFilesToCache());\n});\n\nself.addEventListener('activate', (event) => {\n\t// Remove previous cached data from disk\n\tasync function deleteOldCaches() {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t}\n\n\tevent.waitUntil(deleteOldCaches());\n});\n\nself.addEventListener('fetch', (event) => {\n\t// ignore POST requests etc\n\tif (event.request.method !== 'GET') return;\n\n\tasync function respond() {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\n\t\t// `build`/`files` can always be served from the cache\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\treturn cache.match(url.pathname);\n\t\t}\n\n\t\t// for everything else, try the network first, but\n\t\t// fall back to the cache if we're offline\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\n\t\t\tif (response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch {\n\t\t\treturn cache.match(event.request);\n\t\t}\n\t}\n\n\tevent.respondWith(respond());\n});\n```\n\n> Be careful when caching! In some cases, stale data might be worse than data that's unavailable while offline. Since browsers will empty caches if they get too", "doc_id": "5ed23912-cad5-4091-ab7d-ad1bc537457a", "embedding": null, "doc_hash": "9e979bbfa9183a2b0d646a1b7d2cb3cd24c628f578a57629cfd1917654103232", "extra_info": null, "node_info": {"start": 0, "end": 3390, "_node_type": "1"}, "relationships": {"1": "08a70bf9-6a2e-43ca-824b-7fb2af0639d4", "3": "1a235a14-b4b9-412a-b33c-8765f894555d"}}, "__type__": "1"}, "1a235a14-b4b9-412a-b33c-8765f894555d": {"__data__": {"text": "that's unavailable while offline. Since browsers will empty caches if they get too full, you should also be careful about caching large assets like video files.\n\n## During development\n\nThe service worker is bundled for production, but not during development. For that reason, only browsers that support [modules in service workers](https://web.dev/es-modules-in-sw) will be able to use them at dev time. If you are manually registering your service worker, you will need to pass the `{ type: 'module' }` option in development:\n\n```js\nimport { dev } from '$app/environment';\n\nnavigator.serviceWorker.register('/service-worker.js', {\n\ttype: dev ? 'module' : 'classic'\n});\n```\n\n> `build` and `prerendered` are empty arrays during development\n\n## Type safety\n\nSetting up proper types for service workers requires some manual setup. Inside your `service-worker.js`, add the following to the top of your file:\n\n```original-js\n/// <reference types=\"@sveltejs/kit\" />\n/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\n\nconst sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {unknown} */ (self));\n```\n```generated-ts\n/// <reference types=\"@sveltejs/kit\" />\n/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\n\nconst sw = self as unknown as ServiceWorkerGlobalScope;\n```\n\nThis disables access to DOM typings like `HTMLElement` which are not available inside a service worker and instantiates the correct globals. The reassignment of `self` to `sw` allows you to type cast it in the process (there are a couple of ways to do this, but the easiest that requires no additional files). Use `sw` instead of `self` in the rest of the file. The reference to the SvelteKit types ensures that the `$service-worker` import has proper type definitions.\n\n## Other solutions\n\nSvelteKit's service worker implementation is deliberately low-level. If you need a more full-flegded but also more opinionated solution, we recommend looking at solutions like [Vite PWA plugin](https://vite-pwa-org.netlify.app/frameworks/sveltekit.html), which uses [Workbox](https://web.dev/learn/pwa/workbox). For more general information on service workers, we recommend [the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers).\n", "doc_id": "1a235a14-b4b9-412a-b33c-8765f894555d", "embedding": null, "doc_hash": "d9d558f873dc3d98dfa54167c83a94a4dcb8109df029c7084fc312825c602f8f", "extra_info": null, "node_info": {"start": 3308, "end": 5659, "_node_type": "1"}, "relationships": {"1": "08a70bf9-6a2e-43ca-824b-7fb2af0639d4", "2": "5ed23912-cad5-4091-ab7d-ad1bc537457a"}}, "__type__": "1"}, "515a46bb-d1ab-411c-ba2b-cc094c49315a": {"__data__": {"text": "---\ntitle: Types\n---\n\n## Public types\n\nThe following types can be imported from `@sveltejs/kit`:\n\n> TYPES: @sveltejs/kit\n\n## Private types\n\nThe following are referenced by the public types documented above, but cannot be imported directly:\n\n> TYPES: Private types\n\n## Generated types\n\nThe `RequestHandler` and `Load` types both accept a `Params` argument allowing you to type the `params` object. For example this endpoint expects `foo`, `bar` and `baz` params:\n\n```js\n/// file: src/routes/[foo]/[bar]/[baz]/+page.server.js\n// @errors: 2355 2322 1360\n/** @type {import('@sveltejs/kit').RequestHandler<{\n *   foo: string;\n *   bar: string;\n *   baz: string\n * }>} */\nexport async function GET({ params }) {\n\t// ...\n}\n```\n\nNeedless to say, this is cumbersome to write out, and less portable (if you were to rename the `[foo]` directory to `[qux]`, the type would no longer reflect reality).\n\nTo solve this problem, SvelteKit generates `.d.ts` files for each of your endpoints and pages:\n\n```ts\n/// file: .svelte-kit/types/src/routes/[foo]/[bar]/[baz]/$types.d.ts\n/// link: false\nimport type * as Kit from '@sveltejs/kit';\n\ntype RouteParams = {\n\tfoo: string;\n\tbar: string;\n\tbaz: string;\n}\n\nexport type PageServerLoad = Kit.ServerLoad<RouteParams>;\nexport type PageLoad = Kit.Load<RouteParams>;\n```\n\nThese files can be imported into your endpoints and pages as siblings, thanks to the [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs) option in your TypeScript configuration:\n\n```js\n/// file: src/routes/[foo]/[bar]/[baz]/+page.server.js\n// @filename: $types.d.ts\nimport type * as Kit from '@sveltejs/kit';\n\ntype RouteParams = {\n\tfoo: string;\n\tbar: string;\n\tbaz: string;\n}\n\nexport type PageServerLoad = Kit.ServerLoad<RouteParams>;\n\n// @filename: index.js\n// @errors: 2355\n// ---cut---\n/** @type {import('./$types').PageServerLoad} */\nexport async function GET({ params }) {\n\t// ...\n}\n```\n\n```js\n/// file: src/routes/[foo]/[bar]/[baz]/+page.js\n// @filename: $types.d.ts\nimport type * as Kit from '@sveltejs/kit';\n\ntype RouteParams = {\n\tfoo: string;\n\tbar: string;\n\tbaz: string;\n}\n\nexport type PageLoad = Kit.Load<RouteParams>;\n\n// @filename: index.js\n// @errors: 2355\n// ---cut---\n/** @type {import('./$types').PageLoad} */\nexport async function load({ params, fetch }) {\n\t// ...\n}\n```\n\n> For this to work, your own `tsconfig.json` or `jsconfig.json` should extend from the generated `.svelte-kit/tsconfig.json` (where `.svelte-kit` is your [`outDir`](configuration#outdir)):\n>\n>     { \"extends\": \"./.svelte-kit/tsconfig.json\" }\n\n### Default tsconfig.json\n\nThe generated `.svelte-kit/tsconfig.json` file contains a mixture of options. Some are generated programmatically based on your project configuration, and should generally not be overridden without good reason:\n\n```json\n/// file: .svelte-kit/tsconfig.json\n{\n\t\"compilerOptions\":", "doc_id": "515a46bb-d1ab-411c-ba2b-cc094c49315a", "embedding": null, "doc_hash": "9d8ab5ba8d0075c0298c2d7d1bcf6a4de49468df25ad28b6ea636006918149aa", "extra_info": null, "node_info": {"start": 0, "end": 2842, "_node_type": "1"}, "relationships": {"1": "d883be15-009e-4f33-9e07-66aa9849540f", "3": "2821bf66-16a8-4b94-90d7-e46e2e73c35a"}}, "__type__": "1"}, "2821bf66-16a8-4b94-90d7-e46e2e73c35a": {"__data__": {"text": ".svelte-kit/tsconfig.json\n{\n\t\"compilerOptions\": {\n\t\t\"baseUrl\": \"..\",\n\t\t\"paths\": {\n\t\t\t\"$lib\": \"src/lib\",\n\t\t\t\"$lib/*\": \"src/lib/*\"\n\t\t},\n\t\t\"rootDirs\": [\"..\", \"./types\"]\n\t},\n\t\"include\": [\"../src/**/*.js\", \"../src/**/*.ts\", \"../src/**/*.svelte\"],\n\t\"exclude\": [\"../node_modules/**\", \"./**\"]\n}\n```\n\nOthers are required for SvelteKit to work properly, and should also be left untouched unless you know what you're doing:\n\n```json\n/// file: .svelte-kit/tsconfig.json\n{\n\t\"compilerOptions\": {\n\t\t// this ensures that types are explicitly\n\t\t// imported with `import type`, which is\n\t\t// necessary as svelte-preprocess cannot\n\t\t// otherwise compile components correctly\n\t\t\"importsNotUsedAsValues\": \"error\",\n\n\t\t// Vite compiles one TypeScript module\n\t\t// at a time, rather than compiling\n\t\t// the entire module graph\n\t\t\"isolatedModules\": true,\n\n\t\t// TypeScript cannot 'see' when you\n\t\t// use an imported value in your\n\t\t// markup, so we need this\n\t\t\"preserveValueImports\": true,\n\n\t\t// This ensures both `vite build`\n\t\t// and `svelte-package` work correctly\n\t\t\"lib\": [\"esnext\", \"DOM\", \"DOM.Iterable\"],\n\t\t\"moduleResolution\": \"node\",\n\t\t\"module\": \"esnext\",\n\t\t\"target\": \"esnext\"\n\t}\n}\n```\n\n## App\n\n> TYPES: App\n", "doc_id": "2821bf66-16a8-4b94-90d7-e46e2e73c35a", "embedding": null, "doc_hash": "b967d688fd3b0604096562fb1c73947624f4d892bb53c58a949723f9819b6044", "extra_info": null, "node_info": {"start": 2795, "end": 3985, "_node_type": "1"}, "relationships": {"1": "d883be15-009e-4f33-9e07-66aa9849540f", "2": "515a46bb-d1ab-411c-ba2b-cc094c49315a"}}, "__type__": "1"}, "3852a73d-4701-4629-bd2c-60e0a9fc3a11": {"__data__": {"text": "---\ntitle: Web standards\n---\n\nThroughout this documentation, you'll see references to the standard [Web APIs](https://developer.mozilla.org/en-US/docs/Web/API) that SvelteKit builds on top of. Rather than reinventing the wheel, we _use the platform_, which means your existing web development skills are applicable to SvelteKit. Conversely, time spent learning SvelteKit will help you be a better web developer elsewhere.\n\nThese APIs are available in all modern browsers and in many non-browser environments like Cloudflare Workers, Deno and Vercel Edge Functions. During development, and in [adapters](adapters) for Node-based environments (including AWS Lambda), they're made available via polyfills where necessary (for now, that is \u2014 Node is rapidly adding support for more web standards).\n\nIn particular, you'll get comfortable with the following:\n\n## Fetch APIs\n\nSvelteKit uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) for getting data from the network. It's available in [hooks](hooks) and [server routes](routing#server) as well as in the browser.\n\n> A special version of `fetch` is available in [`load`](load) functions, [server hooks](hooks#server-hooks) and [API routes](routing#server) for invoking endpoints directly during server-side rendering, without making an HTTP call, while preserving credentials. (To make credentialled fetches in server-side code outside `load`, you must explicitly pass `cookie` and/or `authorization` headers.) It also allows you to make relative requests, whereas server-side `fetch` normally requires a fully qualified URL.\n\nBesides `fetch` itself, the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) includes the following interfaces:\n\n### Request\n\nAn instance of [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) is accessible in [hooks](hooks) and [server routes](routing#server) as `event.request`. It contains useful methods like `request.json()` and `request.formData()` for getting data that was posted to an endpoint.\n\n### Response\n\nAn instance of [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) is returned from `await fetch(...)` and handlers in `+server.js` files. Fundamentally, a SvelteKit app is a machine for turning a `Request` into a `Response`.\n\n### Headers\n\nThe [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) interface allows you to read incoming `request.headers` and set outgoing `response.headers`:\n\n```js\n// @errors: 2461\n/// file: src/routes/what-is-my-user-agent/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET(event) {\n\t// log all headers\n\tconsole.log(...event.request.headers);\n\n\treturn json({\n\t\t// retrieve a specific header\n\t\tuserAgent: event.request.headers.get('user-agent')\n\t});\n}\n```\n\n## FormData\n\nWhen dealing with HTML native form submissions you'll be working with [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) objects.\n\n```js\n// @errors: 2461\n/// file: src/routes/hello/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\n\t// log all fields\n\tconsole.log([...body]);\n\n\treturn", "doc_id": "3852a73d-4701-4629-bd2c-60e0a9fc3a11", "embedding": null, "doc_hash": "87b451d158b9da5fdb7aa37a229080b55a8f0207e8d4d273cc70097bafcb33bb", "extra_info": null, "node_info": {"start": 0, "end": 3298, "_node_type": "1"}, "relationships": {"1": "83cf7b29-9651-4de8-9a4d-71dfef9c7119", "3": "1677de5e-20aa-40c2-820d-b4c3c90a5d5a"}}, "__type__": "1"}, "1677de5e-20aa-40c2-820d-b4c3c90a5d5a": {"__data__": {"text": "log all fields\n\tconsole.log([...body]);\n\n\treturn json({\n\t\t// get a specific field's value\n\t\tname: body.get('name') ?? 'world'\n\t});\n}\n```\n\n## Stream APIs\n\nMost of the time, your endpoints will return complete data, as in the `userAgent` example above. Sometimes, you may need to return a response that's too large to fit in memory in one go, or is delivered in chunks, and for this the platform provides [streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) \u2014 [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), [WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) and [TransformStream](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream).\n\n## URL APIs\n\nURLs are represented by the [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) interface, which includes useful properties like `origin` and `pathname` (and, in the browser, `hash`). This interface shows up in various places \u2014 `event.url` in [hooks](hooks) and [server routes](routing#server), [`$page.url`](modules#$app-stores) in [pages](routing#page), `from` and `to` in [`beforeNavigate` and `afterNavigate`](modules#$app-navigation) and so on.\n\n### URLSearchParams\n\nWherever you encounter a URL, you can access query parameters via `url.searchParams`, which is an instance of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):\n\n```js\n// @filename: ambient.d.ts\ndeclare global {\n\tconst url: URL;\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\nconst foo = url.searchParams.get('foo');\n```\n\n## Web Crypto\n\nThe [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) is made available via the `crypto` global. It's used internally for [Content Security Policy](configuration#csp) headers, but you can also use it for things like generating UUIDs:\n\n```js\nconst uuid = crypto.randomUUID();\n```\n", "doc_id": "1677de5e-20aa-40c2-820d-b4c3c90a5d5a", "embedding": null, "doc_hash": "cd97ee2990a38b9906ea3ebdf6f18b4bb596b45a503707a9569748190b92c2ae", "extra_info": null, "node_info": {"start": 3250, "end": 5165, "_node_type": "1"}, "relationships": {"1": "83cf7b29-9651-4de8-9a4d-71dfef9c7119", "2": "3852a73d-4701-4629-bd2c-60e0a9fc3a11"}}, "__type__": "1"}, "62be6dff-851b-4bf3-b31d-091d7d26b0d2": {"__data__": {"text": "---\ntitle: Static site generation\n---\n\nTo use SvelteKit as a static site generator (SSG), use [`adapter-static`](https://github.com/sveltejs/kit/tree/master/packages/adapter-static).\n\nThis will prerender your entire site as a collection of static files. If you'd like to prerender only some pages and dynamically server-render others, you will need to use a different adapter together with [the `prerender` option](page-options#prerender).\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-static`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown. On some platforms\n\t\t\t// these options are set automatically \u2014 see below\n\t\t\tpages: 'build',\n\t\t\tassets: 'build',\n\t\t\tfallback: undefined,\n\t\t\tprecompress: false,\n\t\t\tstrict: true\n\t\t})\n\t}\n};\n```\n\n...and add the [`prerender`](page-options#prerender) option to your root layout:\n\n```js\n/// file: src/routes/+layout.js\n// This can be false if you're using a fallback (i.e. SPA mode)\nexport const prerender = true;\n```\n\n> You must ensure SvelteKit's [`trailingSlash`](page-options#trailingslash) option is set appropriately for your environment. If your host does not render `/a.html` upon receiving a request for `/a` then you will need to set `trailingSlash: 'always'` to create `/a/index.html` instead.\n\n## Zero-config support\n\nSome platforms have zero-config support (more to come in future):\n\n- [Vercel](https://vercel.com)\n\nOn these platforms, you should omit the adapter options so that `adapter-static` can provide the optimal configuration:\n\n```diff\n/// file: svelte.config.js\nexport default {\n\tkit: {\n-\t\tadapter: adapter({...})\n+\t\tadapter: adapter()\n\t}\n};\n```\n\n## Options\n\n### pages\n\nThe directory to write prerendered pages to. It defaults to `build`.\n\n### assets\n\nThe directory to write static assets (the contents of `static`, plus client-side JS and CSS generated by SvelteKit) to. Ordinarily this should be the same as `pages`, and it will default to whatever the value of `pages` is, but in rare circumstances you might need to output pages and assets to separate locations.\n\n### fallback\n\nSpecify a fallback page for [SPA mode](single-page-apps), e.g. `index.html` or `200.html` or `404.html`.\n\n### precompress\n\nIf `true`, precompresses files with brotli and gzip. This will generate `.br` and `.gz` files.\n\n### strict\n\nBy default, `adapter-static` checks that either all pages and endpoints (if any) of your app were prerendered, or you have the `fallback` option set. This check exists to prevent you from accidentally publishing an app where some parts of it are not accessible, because they are not contained in the final output. If you know this is ok (for example when a certain page only exists conditionally), you can set `strict` to `false` to turn off this check.\n\n## GitHub Pages\n\nWhen building for GitHub Pages, make sure to update [`paths.base`](configuration#paths) to match your repo name, since the site will be served from <https://your-username.github.io/your-repo-name> rather than from the root.\n\nYou will have to prevent GitHub's provided Jekyll from managing your site by putting an empty `.nojekyll` file in your `static` folder.\n\nA config for", "doc_id": "62be6dff-851b-4bf3-b31d-091d7d26b0d2", "embedding": null, "doc_hash": "9c27a9e39ffc48671a7cd8c57e481bed795a42dd298e331de1d296c6413abc8c", "extra_info": null, "node_info": {"start": 0, "end": 3302, "_node_type": "1"}, "relationships": {"1": "8240a462-a53d-4034-80c1-86da524f7604", "3": "d28f7364-0ace-4dad-bb92-86620a42231b"}}, "__type__": "1"}, "d28f7364-0ace-4dad-bb92-86620a42231b": {"__data__": {"text": "empty `.nojekyll` file in your `static` folder.\n\nA config for GitHub Pages might look like the following:\n\n```js\n// @errors: 2307 2322\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\nconst dev = process.argv.includes('dev');\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter(),\n\t\tpaths: {\n\t\t\tbase: dev ? '' : process.env.BASE_PATH,\n\t\t}\n\t}\n};\n```\n\nYou can use GitHub actions to automatically deploy your site to GitHub Pages when you make a change. Here's an example workflow:\n\n```yaml\n/// file: .github/workflows/deploy.yml\nname: Deploy to GitHub Pages\n\non:\n  push:\n    branches: 'main'\n\njobs:\n  build_site:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      # If you're using pnpm, add this step then change the commands and cache key below to use `pnpm`\n      # - name: Install pnpm\n      #   uses: pnpm/action-setup@v2\n      #   with:\n      #     version: 8\n\n      - name: Install Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          cache: npm\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: build\n        env:\n          BASE_PATH: '/your-repo-name'\n        run: |\n          npm run build\n          touch build/.nojekyll\n\n      - name: Upload Artifacts\n        uses: actions/upload-pages-artifact@v1\n        with:\n          # this should match the `pages` option in your adapter-static options\n          path: 'build/'\n\n  deploy:\n    needs: build_site\n    runs-on: ubuntu-latest\n\n    permissions:\n      pages: write\n      id-token: write\n\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    \n    steps:\n      - name: Deploy\n        id: deployment\n        uses: actions/deploy-pages@v1\n```\n", "doc_id": "d28f7364-0ace-4dad-bb92-86620a42231b", "embedding": null, "doc_hash": "f9a69f51ad2dac9f224174775a3d8030adb964fdf30c30dd255f5f54b1dc0223", "extra_info": null, "node_info": {"start": 3241, "end": 5070, "_node_type": "1"}, "relationships": {"1": "8240a462-a53d-4034-80c1-86da524f7604", "2": "62be6dff-851b-4bf3-b31d-091d7d26b0d2"}}, "__type__": "1"}, "662119c8-92c5-4fbb-93cd-96de09c6721b": {"__data__": {"text": "---\ntitle: Server-only modules\n---\n\nLike a good friend, SvelteKit keeps your secrets. When writing your backend and frontend in the same repository, it can be easy to accidentally import sensitive data into your front-end code (environment variables containing API keys, for example). SvelteKit provides a way to prevent this entirely: server-only modules.\n\n## Private environment variables\n\nThe `$env/static/private` and `$env/dynamic/private` modules, which are covered in the [modules](modules) section, can only be imported into modules that only run on the server, such as [`hooks.server.js`](hooks#server-hooks) or [`+page.server.js`](routing#page-page-server-js).\n\n## Your modules\n\nYou can make your own modules server-only in two ways:\n\n- adding `.server` to the filename, e.g. `secrets.server.js`\n- placing them in `$lib/server`, e.g. `$lib/server/secrets.js`\n\n## How it works\n\nAny time you have public-facing code that imports server-only code (whether directly or indirectly)...\n\n```js\n// @errors: 7005\n/// file: $lib/server/secrets.js\nexport const atlantisCoordinates = [/* redacted */];\n```\n\n```js\n// @errors: 2307 7006 7005\n/// file: src/routes/utils.js\nexport { atlantisCoordinates } from '$lib/server/secrets.js';\n\nexport const add = (a, b) => a + b;\n```\n\n```html\n/// file: src/routes/+page.svelte\n<script>\n\timport { add } from './utils.js';\n</script>\n```\n\n...SvelteKit will error:\n\n```\nCannot import $lib/server/secrets.js into public-facing code:\n- src/routes/+page.svelte\n\t- src/routes/utils.js\n\t\t- $lib/server/secrets.js\n```\n\nEven though the public-facing code \u2014 `src/routes/+page.svelte` \u2014 only uses the `add` export and not the secret `atlantisCoordinates` export, the secret code could end up in JavaScript that the browser downloads, and so the import chain is considered unsafe.\n\nThis feature also works with dynamic imports, even interpolated ones like ``await import(`./${foo}.js`)``, with one small caveat: during development, if there are two or more dynamic imports between the public-facing code and the server-only module, the illegal import will not be detected the first time the code is loaded.\n\n> Unit testing frameworks like Vitest do not distinguish between server-only and public-facing code. For this reason, illegal import detection is disabled when running tests, as determined by `process.env.TEST === 'true'`.\n\n## Further reading\n\n- [Tutorial: Environment variables](https://learn.svelte.dev/tutorial/env-static-private)\n", "doc_id": "662119c8-92c5-4fbb-93cd-96de09c6721b", "embedding": null, "doc_hash": "9a9712b4c63846fdd7829ea4d1d0facf21d0ca314ef33059c609264c363741ae", "extra_info": null, "node_info": {"start": 0, "end": 2465, "_node_type": "1"}, "relationships": {"1": "e0db49bf-2954-4a45-9955-0b8209668640"}}, "__type__": "1"}, "7b4c7ef2-cb7b-4c42-8f07-a111e1bd4aa7": {"__data__": {"text": "---\ntitle: State management\n---\n\nIf you're used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas.\n\n## Avoid shared state on the server\n\nBrowsers are _stateful_ \u2014 state is stored in memory as the user interacts with the application. Servers, on the other hand, are _stateless_ \u2014 the content of the response is determined entirely by the content of the request.\n\nConceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it's important not to store data in shared variables. For example, consider this code:\n\n```js\n// @errors: 7034 7005\n/// file: +page.server.js\nlet user;\n\n/** @type {import('./$types').PageServerLoad} */\nexport function load() {\n\treturn { user };\n}\n\n/** @type {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async ({ request }) => {\n\t\tconst data = await request.formData();\n\n\t\t// NEVER DO THIS!\n\t\tuser = {\n\t\t\tname: data.get('name'),\n\t\t\tembarrassingSecret: data.get('secret')\n\t\t};\n\t}\n}\n```\n\nThe `user` variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice's secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.\n\nInstead, you should _authenticate_ the user using [`cookies`](load#cookies-and-headers) and persist the data to a database.\n\n## No side-effects in load\n\nFor the same reason, your `load` functions should be _pure_ \u2014 no side-effects (except maybe the occasional `console.log(...)`). For example, you might be tempted to write to a store inside a `load` function so that you can use the store value in your components:\n\n```js\n/// file: +page.js\n// @filename: ambient.d.ts\ndeclare module '$lib/user' {\n\texport const user: { set: (value: any) => void };\n}\n\n// @filename: index.js\n// ---cut---\nimport { user } from '$lib/user';\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n\t// NEVER DO THIS!\n\tuser.set(await response.json());\n}\n```\n\nAs with the previous example, this puts one user's information in a place that is shared by _all_ users. Instead, just return the data...\n\n```diff\n/// file: +page.js\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n+\treturn {\n+\t\tuser: await response.json()\n+\t};\n}\n```\n\n...and pass it around to the components that need it, or use [`$page.data`](load#$page-data).\n\nIf you're not using SSR, then there's no risk of accidentally exposing one user's data to another. But you should still avoid side-effects in your `load` functions \u2014 your application will be much easier to reason about without them.\n\n## Using stores with context\n\nYou might wonder how we're able to use `$page.data` and other [app stores](modules#$app-stores) if we can't use our own stores. The answer is that app stores on the server use Svelte's [context API](https://learn.svelte.dev/tutorial/context-api) \u2014 the store is attached to the component tree with `setContext`, and when you subscribe you retrieve it with `getContext`. We can do the same thing with our own stores:\n\n```svelte\n/// file: src/routes/+layout.svelte\n<script>\n\timport { setContext } from 'svelte';\n\timport { writable } from", "doc_id": "7b4c7ef2-cb7b-4c42-8f07-a111e1bd4aa7", "embedding": null, "doc_hash": "d9590b4a7abef033b5324cd0e3a04abd1defec5866448a04ad3443efcf0affee", "extra_info": null, "node_info": {"start": 0, "end": 3401, "_node_type": "1"}, "relationships": {"1": "1131f8cd-14c1-4fdf-9982-003d436a8fd0", "3": "79984c12-046f-44f2-b67f-47bc4ced75c6"}}, "__type__": "1"}, "79984c12-046f-44f2-b67f-47bc4ced75c6": {"__data__": {"text": "{ setContext } from 'svelte';\n\timport { writable } from 'svelte/store';\n\n\t/** @type {import('./$types').LayoutData} */\n\texport let data;\n\n\t// Create a store and update it when necessary...\n\tconst user = writable();\n\t$: user.set(data.user);\n\n\t// ...and add it to the context for child components to access\n\tsetContext('user', user);\n</script>\n```\n\n```svelte\n/// file: src/routes/user/+page.svelte\n<script>\n\timport { getContext } from 'svelte';\n\n\t// Retrieve user store from context\n\tconst user = getContext('user');\n</script>\n\n<p>Welcome {$user.name}</p>\n```\n\nIf you're not using SSR (and can guarantee that you won't need to use SSR in future) then you can safely keep state in a shared module, without using the context API.\n\n## Component state is preserved\n\nWhen you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\t// THIS CODE IS BUGGY!\n\tconst wordCount = data.content.split(' ').length;\n\tconst estimatedReadingTime = wordCount / 250;\n</script>\n\n<header>\n\t<h1>{data.title}</h1>\n\t<p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>\n</header>\n\n<div>{@html data.content}</div>\n```\n\n...then navigating from `/blog/my-short-post` to `/blog/my-long-post` won't cause the component to be destroyed and recreated. The `data` prop (and by extension `data.title` and `data.content`) will change, but because the code isn't re-running, `estimatedReadingTime` won't be recalculated.\n\nInstead, we need to make the value [_reactive_](https://learn.svelte.dev/tutorial/reactive-assignments):\n\n```diff\n/// file: src/routes/blog/[slug]/+page.svelte\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n+\t$: wordCount = data.content.split(' ').length;\n+\t$: estimatedReadingTime = wordCount / 250;\n</script>\n```\n\nReusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. However, if you do need to completely destroy and remount a component on navigation, you can use this pattern:\n\n```svelte\n{#key $page.url.pathname}\n\t<BlogPost title={data.title} content={data.title} />\n{/key}\n```\n\n## Storing state in the URL\n\nIf you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like `?sort=price&order=ascending`) are a good place to put them. You can put them in `<a href=\"...\">` or `<form action=\"...\">` attributes, or set them programmatically via `goto('?key=value')`. They can be accessed inside `load` functions via the `url` parameter, and inside components via `$page.url.searchParams`.\n\n## Storing ephemeral state in snapshots\n\nSome UI state, such as 'is the accordion open?', is disposable \u2014 if the user navigates away or refreshes the page, it doesn't matter if the state is lost. In some cases, you _do_ want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides [snapshots](snapshots), which let you associate", "doc_id": "79984c12-046f-44f2-b67f-47bc4ced75c6", "embedding": null, "doc_hash": "819bd16ca976ef47ac7a69f5cd48bcdf755e9d7671a2df762205d37816daef4e", "extra_info": null, "node_info": {"start": 3355, "end": 6582, "_node_type": "1"}, "relationships": {"1": "1131f8cd-14c1-4fdf-9982-003d436a8fd0", "2": "7b4c7ef2-cb7b-4c42-8f07-a111e1bd4aa7", "3": "17829cc8-425a-4921-b81c-a66034cc1fa4"}}, "__type__": "1"}, "17829cc8-425a-4921-b81c-a66034cc1fa4": {"__data__": {"text": "this, SvelteKit provides [snapshots](snapshots), which let you associate component state with a history entry.", "doc_id": "17829cc8-425a-4921-b81c-a66034cc1fa4", "embedding": null, "doc_hash": "4621fb3b987c5a6978f713b396492a900c1dabdc3f92e93fd2c39ccab611f4e9", "extra_info": null, "node_info": {"start": 6557, "end": 6667, "_node_type": "1"}, "relationships": {"1": "1131f8cd-14c1-4fdf-9982-003d436a8fd0", "2": "79984c12-046f-44f2-b67f-47bc4ced75c6"}}, "__type__": "1"}, "24d82c56-31e1-4ed1-bbda-f5b1fe7033fa": {"__data__": {"text": "---\ntitle: Single-page apps\n---\n\nYou can turn any SvelteKit app, using any adapter, into a fully client-rendered single-page app (SPA) by disabling SSR at the root layout:\n\n```js\n/// file: src/routes/+layout.js\nexport const ssr = false;\n```\n\n> In most situations this is not recommended: it harms SEO, tends to slow down perceived performance, and makes your app inaccessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).\n\nIf you don't have any server-side logic (i.e. `+page.server.js`, `+layout.server.js` or `+server.js` files) you can use [`adapter-static`](adapter-static) to create your SPA by adding a _fallback page_.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-static`, then add the adapter to your `svelte.config.js` with the following options:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '200.html' // may differ from host to host\n\t\t})\n\t}\n};\n```\n\nThe `fallback` page is an HTML page created by SvelteKit from your page template (e.g. `app.html`) that loads your app and navigates to the correct route. For example [Surge](https://surge.sh/help/adding-a-200-page-for-client-side-routing), a static web host, lets you add a `200.html` file that will handle any requests that don't correspond to static assets or prerendered pages.\n\nOn some hosts it may be `index.html` or something else entirely \u2014 consult your platform's documentation.\n\n## Apache\n\nTo run an SPA on [Apache](https://httpd.apache.org/), you should add a `static/.htaccess` file to route requests to the fallback page:\n\n```\n<IfModule mod_rewrite.c>\n\tRewriteEngine On\n\tRewriteBase /\n\tRewriteRule ^200\\.html$ - [L]\n\tRewriteCond %{REQUEST_FILENAME} !-f\n\tRewriteCond %{REQUEST_FILENAME} !-d\n\tRewriteRule . /200.html [L]\n</IfModule>\n```\n\n## Prerendering individual pages\n\nIf you want certain pages to be prerendered, you can re-enable `ssr` alongside `prerender` for just those parts of your app:\n\n```js\n/// file: src/routes/my-prerendered-page/+page.js\nexport const prerender = true;\nexport const ssr = true;\n```", "doc_id": "24d82c56-31e1-4ed1-bbda-f5b1fe7033fa", "embedding": null, "doc_hash": "a9e81a6470c7a42a6a7d44c59553785ae0a4f040ef17c16423dd89e41f44ed13", "extra_info": null, "node_info": {"start": 0, "end": 2212, "_node_type": "1"}, "relationships": {"1": "ba251ef5-e8cb-40ef-835f-24984c9ef3ed"}}, "__type__": "1"}, "157d4e59-d8bc-4970-a501-61d3b3447588": {"__data__": {"text": "---\ntitle: Cloudflare Pages\n---\n\nTo deploy to [Cloudflare Pages](https://developers.cloudflare.com/pages/), use [`adapter-cloudflare`](https://github.com/sveltejs/kit/tree/master/packages/adapter-cloudflare).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project is recommended so that `event.platform` is automatically typed.\n\n## Comparisons\n\n- `adapter-cloudflare` \u2013 supports all SvelteKit features; builds for [Cloudflare Pages](https://blog.cloudflare.com/cloudflare-pages-goes-full-stack/)\n- `adapter-cloudflare-workers` \u2013 supports all SvelteKit features; builds for Cloudflare Workers\n- `adapter-static` \u2013 only produces client-side static assets; compatible with Cloudflare Pages\n\n> Unless you have a specific reason to use `adapter-cloudflare-workers`, it's recommended that you use this adapter instead. Both adapters have equivalent functionality, but Cloudflare Pages offers features like GitHub integration with automatic builds and deploys, preview deployments, instant rollback and so on.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-cloudflare`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-cloudflare';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// See below for an explanation of these options\n\t\t\troutes: {\n\t\t\t\tinclude: ['/*'],\n\t\t\t\texclude: ['<all>']\n\t\t\t}\n\t\t})\n\t}\n};\n```\n\n## Options\n\nThe `routes` option allows you to customise the [`_routes.json`](https://developers.cloudflare.com/pages/platform/functions/routing/#create-a-_routesjson-file) file generated by `adapter-cloudflare`.\n\n- `include` defines routes that will invoke a function, and defaults to `['/*']`\n- `exclude` defines routes that will _not_ invoke a function \u2014 this is a faster and cheaper way to serve your app's static assets. This array can include the following special values:\n\t- `<build>` contains your app's build artifacts (the files generated by Vite)\n\t- `<files>` contains the contents of your `static` directory\n\t- `<prerendered>` contains a list of prerendered pages\n\t- `<all>` (the default) contains all of the above\n\nYou can have up to 100 `include` and `exclude` rules combined. Generally you can omit the `routes` options, but if (for example) your `<prerendered>` paths exceed that limit, you may find it helpful to manually create an `exclude` list that includes `'/articles/*'` instead of the auto-generated `['/articles/foo', '/articles/bar', '/articles/baz', ...]`.\n\n## Deployment\n\nPlease follow the [Get Started Guide](https://developers.cloudflare.com/pages/get-started) for Cloudflare Pages to begin.\n\nWhen configuring your project settings, you must use the following settings:\n\n- **Framework preset** \u2013 None\n- **Build command** \u2013 `npm run build` or `vite build`\n- **Build output directory** \u2013 `.svelte-kit/cloudflare`\n- **Environment variables**\n\t- `NODE_VERSION`: `16`\n\n> You need to add a `NODE_VERSION` environment variable to both the \"production\" and \"preview\" environments. You can add this during project setup or later in the Pages project settings. SvelteKit requires Node `16.14` or later, so you should use `16` as the `NODE_VERSION` value.\n\n## Environment variables\n\nThe", "doc_id": "157d4e59-d8bc-4970-a501-61d3b3447588", "embedding": null, "doc_hash": "566ebeefb0fc5249347288c4888cf45cc0e493b2f2ccacfd44c5353a320ff038", "extra_info": null, "node_info": {"start": 0, "end": 3264, "_node_type": "1"}, "relationships": {"1": "51fcdaa3-85f2-49c0-8964-2b74e5ebaf61", "3": "75e0c4f2-1c1e-41dc-ad32-fc819ff03365"}}, "__type__": "1"}, "75e0c4f2-1c1e-41dc-ad32-fc819ff03365": {"__data__": {"text": "as the `NODE_VERSION` value.\n\n## Environment variables\n\nThe [`env`](https://developers.cloudflare.com/workers/runtime-apis/fetch-event#parameters) object, containing KV/DO namespaces etc, is passed to SvelteKit via the `platform` property along with `context` and `caches`, meaning you can access it in hooks and endpoints:\n\n```js\n// @errors: 7031\nexport async function POST({ request, platform }) {\n\tconst x = platform.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\nTo make these types available to your app, reference them in your `src/app.d.ts`:\n\n```diff\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n+\t\t\tenv?: {\n+\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n+\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n+\t\t\t};\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n> `platform.env` is only available in the production build. Use [wrangler](https://developers.cloudflare.com/workers/cli-wrangler) to test it locally\n\n## Notes\n\nFunctions contained in the `/functions` directory at the project's root will _not_ be included in the deployment, which is compiled to a [single `_worker.js` file](https://developers.cloudflare.com/pages/platform/functions/#advanced-mode). Functions should be implemented as [server endpoints](https://kit.svelte.dev/docs/routing#server) in your SvelteKit app.\n\nThe `_headers` and `_redirects` files specific to Cloudflare Pages can be used for static asset responses (like images) by putting them into the `/static` folder.\n\nHowever, they will have no effect on responses dynamically rendered by SvelteKit, which should return custom headers or redirect responses from [server endpoints](https://kit.svelte.dev/docs/routing#server) or with the [`handle`](https://kit.svelte.dev/docs/hooks#server-hooks-handle) hook.\n\n## Troubleshooting\n\n### Accessing the file system\n\nYou can't access the file system through methods like `fs.readFileSync` in Serverless/Edge environments. If you need to access files that way, do that during building the app through [prerendering](https://kit.svelte.dev/docs/page-options#prerender). If you have a blog for example and don't want to manage your content through a CMS, then you need to prerender the content (or prerender the endpoint from which you get it) and redeploy your blog everytime you add new content.\n", "doc_id": "75e0c4f2-1c1e-41dc-ad32-fc819ff03365", "embedding": null, "doc_hash": "e620c00a65b70a82394de5050ab266185fcbc7b1b86bdec9cd59c17b7d4b8e4e", "extra_info": null, "node_info": {"start": 3205, "end": 5504, "_node_type": "1"}, "relationships": {"1": "51fcdaa3-85f2-49c0-8964-2b74e5ebaf61", "2": "157d4e59-d8bc-4970-a501-61d3b3447588"}}, "__type__": "1"}, "78a3d669-2ba9-4a4c-8ae5-13c8e415bdfc": {"__data__": {"text": "---\ntitle: Asset handling\n---\n\n## Caching and inlining\n\n[Vite will automatically process imported assets](https://vitejs.dev/guide/assets.html) for improved performance. Hashes will be added to the filenames so that they can be cached and assets smaller than `assetsInlineLimit` will be inlined.\n\n```html\n<script>\n\timport logo from '$lib/assets/logo.png';\n</script>\n\n<img alt=\"The project logo\" src={logo} />\n```\n\nIf you prefer to reference assets directly in the markup, you can use a preprocessor such as [svelte-preprocess-import-assets](https://github.com/bluwy/svelte-preprocess-import-assets).\n\nFor assets included via the CSS `url()` function, you may find [`vitePreprocess`](https://kit.svelte.dev/docs/integrations#preprocessors-vitepreprocess) useful.\n\n## Transforming\n\nYou may wish to transform your images to output compressed image formats such as `.webp` or `.avif`, responsive images with different sizes for different devices, or images with the EXIF data stripped for privacy. For images that are included statically, you may use a Vite plugin such as [vite-imagetools](https://github.com/JonasKruckenberg/imagetools). You may also consider a CDN, which can serve the appropriate transformed image based on the `Accept` HTTP header and query string parameters.\n", "doc_id": "78a3d669-2ba9-4a4c-8ae5-13c8e415bdfc", "embedding": null, "doc_hash": "6e7747f19cd6483636988033453a9c7207ac165cbe75813f3e2eda7c36d523c8", "extra_info": null, "node_info": {"start": 0, "end": 1278, "_node_type": "1"}, "relationships": {"1": "86af7db9-24a4-4bdc-80a4-b1e36f58bf9b"}}, "__type__": "1"}, "4a67e605-011e-4481-933a-e60a147cf5d2": {"__data__": {"text": "---\ntitle: Snapshots\n---\n\nEphemeral DOM state \u2014 like scroll positions on sidebars, the content of `<input>` elements and so on \u2014 is discarded when you navigate from one page to another.\n\nFor example, if the user fills out a form but clicks a link before submitting, then hits the browser's back button, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a _snapshot_ of DOM state, which can then be restored if the user navigates back.\n\nTo do this, export a `snapshot` object with `capture` and `restore` methods from a `+page.svelte` or `+layout.svelte`:\n\n```svelte\n/// file: +page.svelte\n<script>\n\tlet comment = '';\n\n\t/** @type {import('./$types').Snapshot<string>} */\n\texport const snapshot = {\n\t\tcapture: () => comment,\n\t\trestore: (value) => comment = value\n\t};\n</script>\n\n<form method=\"POST\">\n\t<label for=\"comment\">Comment</label>\n\t<textarea id=\"comment\" bind:value={comment} />\n\t<button>Post comment</button>\n</form>\n```\n\nWhen you navigate away from this page, the `capture` function is called immediately before the page updates, and the returned value is associated with the current entry in the browser's history stack. If you navigate back, the `restore` function is called with the stored value as soon as the page is updated.\n\nThe data must be serializable as JSON so that it can be persisted to `sessionStorage`. This allows the state to be restored when the page is reloaded, or when the user navigates back from a different site.\n\n> Avoid returning very large objects from `capture` \u2014 once captured, objects will be retained in memory for the duration of the session, and in extreme cases may be too large to persist to `sessionStorage`.\n", "doc_id": "4a67e605-011e-4481-933a-e60a147cf5d2", "embedding": null, "doc_hash": "0456468909fa48748ae951861303bafb1cd89bf19938f05a97fd4fae38712f15", "extra_info": null, "node_info": {"start": 0, "end": 1708, "_node_type": "1"}, "relationships": {"1": "17c0a953-848a-4041-90ea-e03c8605e063"}}, "__type__": "1"}, "c7a65a0f-de49-45b9-9cec-79cc94ee5ea3": {"__data__": {"text": "---\ntitle: Cloudflare Workers\n---\n\nTo deploy to [Cloudflare Workers](https://workers.cloudflare.com/), use [`adapter-cloudflare-workers`](https://github.com/sveltejs/kit/tree/master/packages/adapter-cloudflare-workers).\n\nUnless you have a specific reason to use this adapter, we recommend using [`adapter-cloudflare`](adapter-cloudflare) instead.\n\n> Requires [Wrangler v2](https://developers.cloudflare.com/workers/wrangler/get-started/).\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-cloudflare-workers`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-cloudflare-workers';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Basic Configuration\n\nThis adapter expects to find a [wrangler.toml](https://developers.cloudflare.com/workers/platform/sites/configuration) file in the project root. It should look something like this:\n\n```toml\n/// file: wrangler.toml\nname = \"<your-service-name>\"\naccount_id = \"<your-account-id>\"\n\nmain = \"./.cloudflare/worker.js\"\nsite.bucket = \"./.cloudflare/public\"\n\nbuild.command = \"npm run build\"\n\ncompatibility_date = \"2021-11-12\"\nworkers_dev = true\n```\n\n`<your-service-name>` can be anything. `<your-account-id>` can be found by logging into your [Cloudflare dashboard](https://dash.cloudflare.com) and grabbing it from the end of the URL:\n\n```\nhttps://dash.cloudflare.com/<your-account-id>\n```\n\n> You should add the `.cloudflare` directory (or whichever directories you specified for `main` and `site.bucket`) to your `.gitignore`.\n\nYou will need to install [wrangler](https://developers.cloudflare.com/workers/wrangler/get-started/) and log in, if you haven't already:\n\n```\nnpm i -g wrangler\nwrangler login\n```\n\nThen, you can build your app and deploy it:\n\n```sh\nwrangler publish\n```\n\n## Custom config\n\nIf you would like to use a config file other than `wrangler.toml`, you can do like so:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-cloudflare-workers';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({ config: '<your-wrangler-name>.toml' })\n\t}\n};\n```\n\n## Environment variables\n\nThe [`env`](https://developers.cloudflare.com/workers/runtime-apis/fetch-event#parameters) object, containing KV/DO namespaces etc, is passed to SvelteKit via the `platform` property along with `context` and `caches`, meaning you can access it in hooks and endpoints:\n\n```js\n// @errors: 7031\nexport async function POST({ request, platform }) {\n\tconst x = platform.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\nTo make these types available to your app, reference them in your `src/app.d.ts`:\n\n```diff\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n+\t\t\tenv?: {\n+\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n+\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE:", "doc_id": "c7a65a0f-de49-45b9-9cec-79cc94ee5ea3", "embedding": null, "doc_hash": "0a28f4cdac8b3c2f0e5210cfc62841d0accb84d619a2348f49ce8c90e008b698", "extra_info": null, "node_info": {"start": 0, "end": 2842, "_node_type": "1"}, "relationships": {"1": "4c2731f7-d73c-4ffd-8884-444d4e65c24f", "3": "865f170b-a4b2-4df8-a4e1-8fe54b46ce33"}}, "__type__": "1"}, "865f170b-a4b2-4df8-a4e1-8fe54b46ce33": {"__data__": {"text": "DurableObjectNamespace;\n+\t\t\t};\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n> `platform.env` is only available in the production build. Use [wrangler](https://developers.cloudflare.com/workers/cli-wrangler) to test it locally\n\n## Troubleshooting\n\n### Worker size limits\n\nWhen deploying to workers, the server generated by SvelteKit is bundled into a single file. Wrangler will fail to publish your worker if it exceeds [the size limits](https://developers.cloudflare.com/workers/platform/limits/#worker-size) after minification. You're unlikely to hit this limit usually, but some large libraries can cause this to happen. In that case, you can try to reduce the size of your worker by only importing such libraries on the client side. See [the FAQ](../faq#how-do-i-use-a-client-side-only-library-that-depends-on-document-or-window) for more information.\n\n### Accessing the file system\n\nYou can't access the file system through methods like `fs.readFileSync` in Serverless/Edge environments. If you need to access files that way, do that during building the app through [prerendering](https://kit.svelte.dev/docs/page-options#prerender). If you have a blog for example and don't want to manage your content through a CMS, then you need to prerender the content (or prerender the endpoint from which you get it) and redeploy your blog everytime you add new content.", "doc_id": "865f170b-a4b2-4df8-a4e1-8fe54b46ce33", "embedding": null, "doc_hash": "5a744060a761980f973ccd6c06c6ff07d49c75a1d8084c7a16107347cf13ba67", "extra_info": null, "node_info": {"start": 2843, "end": 4188, "_node_type": "1"}, "relationships": {"1": "4c2731f7-d73c-4ffd-8884-444d4e65c24f", "2": "c7a65a0f-de49-45b9-9cec-79cc94ee5ea3"}}, "__type__": "1"}, "d85d8bb7-838b-44c5-ab16-a287e6f89818": {"__data__": {"text": "---\ntitle: Packaging\n---\n\nYou can use SvelteKit to build apps as well as component libraries, using the `@sveltejs/package` package (`npm create svelte` has an option to set this up for you).\n\nWhen you're creating an app, the contents of `src/routes` is the public-facing stuff; [`src/lib`](modules#$lib) contains your app's internal library.\n\nA component library has the exact same structure as a SvelteKit app, except that `src/lib` is the public-facing bit, and your root `package.json` is used to publish the package. `src/routes` might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.\n\nRunning the `svelte-package` command from `@sveltejs/package` will take the contents of `src/lib` and generate a `dist` directory (which can be [configured](#options)) containing the following:\n\n- All the files in `src/lib`. Svelte components will be preprocessed, TypeScript files will be transpiled to JavaScript.\n- Type definitions (`d.ts` files) which are generated for Svelte, JavaScript and TypeScript files. You need to install `typescript >= 4.0.0` for this. Type definitions are placed next to their implementation, hand-written `d.ts` files are copied over as is. You can [disable generation](#options), but we strongly recommend against it \u2014 people using your library might use TypeScript, for which they require these type definition files.\n\n> `@sveltejs/package` version 1 generated a `package.json`. This is no longer the case and it will now use the `package.json` from your project and validate that it is correct instead. If you're still on version 1, see [this PR](https://github.com/sveltejs/kit/pull/8922) for migration instructions.\n\n## Anatomy of a package.json\n\nSince you're now building a library for public use, the contents of your `package.json` will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let's go through the most important fields one by one.\n\n### name\n\nThis is the name of your package. It will be available for others to install using that name, and visible on `https://npmjs.com/package/<name>`.\n\n```json\n{\n\t\"name\": \"your-library\"\n}\n```\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#name).\n\n### license\n\nEvery package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is `MIT`.\n\n```json\n{\n\t\"license\": \"MIT\"\n}\n```\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#license). Note that you should also include a `LICENSE` file in your package.\n\n### files\n\nThis tells npm which files it will pack up and upload to npm. It should contain your output folder (`dist` by default). Your `package.json` and `README` and `LICENSE` will always be included, so you don't need to specify them.\n\n```json\n{\n\t\"files\": [\"dist\"]\n}\n```\n\nTo exclude unnecessary files (such as unit tests, or modules that are only imported from `src/routes` etc) you can add them to an `.npmignore` file. This will result in smaller packages that are faster to install.\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#files).\n\n### exports\n\nThe `\"exports\"` field contains the package's entry points. If you set up a new library project through `npm create svelte@latest`, it's set to a single export, the package", "doc_id": "d85d8bb7-838b-44c5-ab16-a287e6f89818", "embedding": null, "doc_hash": "fe6e42d7a27093a24b6d622e709e6992981f19a5b2b88850f3dcc06290f484c6", "extra_info": null, "node_info": {"start": 0, "end": 3529, "_node_type": "1"}, "relationships": {"1": "74e019d6-bb00-4f30-891b-54754e3f2bda", "3": "c12087cf-181c-459d-a61f-d840175f99b5"}}, "__type__": "1"}, "c12087cf-181c-459d-a61f-d840175f99b5": {"__data__": {"text": "`npm create svelte@latest`, it's set to a single export, the package root:\n\n```json\n{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n\t\t\t\"svelte\": \"./dist/index.js\"\n\t\t}\n\t}\n}\n```\n\nThis tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this:\n\n```js\n// @errors: 2307\nimport { Something } from 'your-library';\n```\n\nThe `types` and `svelte` keys are [export conditions](https://nodejs.org/api/packages.html#conditional-exports). They tell tooling what file to import when they look up the `your-library` import:\n\n- TypeScript sees the `types` condition and looks up the type definition file. If you don't publish type definitions, omit this condition.\n- Svelte-aware tooling sees the `svelte` condition and knows this is a Svelte component library. If you publish a library that does not export any Svelte components and that could also work in non-Svelte projects (for example a Svelte store library), you can replace this condition with `default`.\n\n> Previous versions of `@sveltejs/package` also added a `package.json` export. This is no longer part of the template because all tooling can now deal with a `package.json` not being explicitly exported.\n\nYou can adjust `exports` to your liking and provide more entry points. For example, if instead of a `src/lib/index.js` file that re-exported components you wanted to expose a `src/lib/Foo.svelte` component directly, you could create the following export map...\n\n```json\n{\n\t\"exports\": {\n\t\t\"./Foo.svelte\": {\n\t\t\t\"types\": \"./dist/Foo.svelte.d.ts\",\n\t\t\t\"svelte\": \"./dist/Foo.svelte\"\n\t\t}\n\t}\n}\n```\n\n...and a consumer of your library could import the component like so:\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'your-library/Foo.svelte';\n\n// @filename: index.js\n// ---cut---\nimport Foo from 'your-library/Foo.svelte';\n```\n\n> Beware that doing this will need additional care if you provide type definitions. Read more about the caveat [here](#typescript)\n\nIn general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.\n\nRead more about `exports` [here](https://nodejs.org/docs/latest-v18.x/api/packages.html#package-entry-points).\n\n### svelte\n\nThis is a legacy field that enabled tooling to recognise Svelte component libraries. It's no longer necessary when using the `svelte` [export condition](#anatomy-of-a-package-json-exports), but for backwards compatibility with outdated tooling that doesn't yet know about export conditions it's good to keep it around. It should point towards your root entry point.\n\n```json\n{\n\t\"svelte\": \"./dist/index.js\"\n}\n```\n\n## TypeScript\n\nYou should ship type definitions for your library even if you don't use TypeScript yourself so that people who do get proper intellisense when using your library. `@sveltejs/package` makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the `types` condition in the [exports](#anatomy-of-a-package-json-exports) map points to the correct files. When initialising a library project through `npm", "doc_id": "c12087cf-181c-459d-a61f-d840175f99b5", "embedding": null, "doc_hash": "6ad2ec31c073ae60e795019960ee5db8f5641a2a448b625775567dbe5b13a679", "extra_info": null, "node_info": {"start": 3472, "end": 6822, "_node_type": "1"}, "relationships": {"1": "74e019d6-bb00-4f30-891b-54754e3f2bda", "2": "d85d8bb7-838b-44c5-ab16-a287e6f89818", "3": "1457c5f6-1b1a-4461-b9dc-840f1fd61af3"}}, "__type__": "1"}, "1457c5f6-1b1a-4461-b9dc-840f1fd61af3": {"__data__": {"text": "map points to the correct files. When initialising a library project through `npm create svelte@latest`, this is automatically setup for the root export.\n\nIf you have something else than a root export however \u2014 for example providing a `your-library/foo` import \u2014 you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will _not_ resolve the `types` condition for an export like `{ \"./foo\": { \"types\": \"./dist/foo.d.ts\", ... }}`. Instead, it will search for a `foo.d.ts` relative to the root of your library (i.e. `your-library/foo.d.ts` instead of `your-library/dist/foo.d.ts`). To fix this, you have two options:\n\nThe first option is to require people using your library to set the `moduleResolution` option in their `tsconfig.json` (or `jsconfig.json`) to `bundler` (available since TypeScript 5, the best and recommended option in the future), `node16` or `nodenext`. This opts TypeScript into actually looking at the exports map and resolving the types correctly.\n\nThe second option is to (ab)use the `typesVersions` feature from TypeScript to wire up the types. This is a field inside `package.json` TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned `foo` export above, the corresponding `typesVersions` looks like this:\n\n```json\n{\n\t\"exports\": {\n\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\"\n\t\t}\n\t},\n\t\"typesVersions\": {\n\t\t\">4.0\": {\n\t\t\t\"foo\": [\"./dist/foo.d.ts\"]\n\t\t}\n\t}\n}\n```\n\n`>4.0` tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for `your-library/foo` are found within `./dist/foo.d.ts`, which essentially replicates the `exports` condition. You also have `*` as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into `typesVersions` you have to declare all type imports through it, including the root import (which is defined as `\"index\": [..]`).\n\nYou can read more about that feature [here](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions).\n\n## Best practices\n\nYou should avoid using [SvelteKit-specific modules](modules) like `$app` in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using `import { browser } from '$app/environment'` you could use `import { BROWSER } from 'esm-env'` ([see esm-env docs](https://github.com/benmccann/esm-env)). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on `$app/stores`, `$app/navigation`, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.\n\nEnsure that you add [aliases](configuration#alias) via `svelte.config.js` (not `vite.config.js` or `tsconfig.json`), so that they are processed by `svelte-package`.\n\nYou should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from `exports` or any `export` conditions inside them from your existing library, that should be regarded as a breaking change.\n\n```diff\n{\n\t\"exports\": {\n\t\t\".\":", "doc_id": "1457c5f6-1b1a-4461-b9dc-840f1fd61af3", "embedding": null, "doc_hash": "157c5e768e8ed8031dfbd2be7ad8ad332d951edbc780ac297fbb7c55ce017ad9", "extra_info": null, "node_info": {"start": 6812, "end": 10369, "_node_type": "1"}, "relationships": {"1": "74e019d6-bb00-4f30-891b-54754e3f2bda", "2": "c12087cf-181c-459d-a61f-d840175f99b5", "3": "2f071c06-dd5f-4340-9a3b-6823eb1572d6"}}, "__type__": "1"}, "2f071c06-dd5f-4340-9a3b-6823eb1572d6": {"__data__": {"text": "{\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n// changing `svelte` to `default` is a breaking change:\n-\t\t\t\"svelte\": \"./dist/index.js\"\n+\t\t\t\"default\": \"./dist/index.js\"\n\t\t},\n// removing this is a breaking change:\n-\t\t\"./foo\": {\n-\t\t\t\"types\": \"./dist/foo.d.ts\",\n-\t\t\t\"svelte\": \"./dist/foo.js\",\n-\t\t\t\"default\": \"./dist/foo.js\"\n-\t\t},\n// adding this is ok:\n+\t\t\"./bar\": {\n+\t\t\t\"types\": \"./dist/bar.d.ts\",\n+\t\t\t\"svelte\": \"./dist/bar.js\",\n+\t\t\t\"default\": \"./dist/bar.js\"\n+\t\t}\n\t}\n}\n```\n\n## Options\n\n`svelte-package` accepts the following options:\n\n- `-w`/`--watch` \u2014 watch files in `src/lib` for changes and rebuild the package\n- `-i`/`--input` \u2014 the input directory which contains all the files of the package. Defaults to `src/lib`\n- `-o`/`--o` \u2014 the output directory where the processed files are written to. Your `package.json`'s `exports` should point to files inside there, and the `files` array should include that folder. Defaults to `dist`\n- `-t`/`--types` \u2014 whether or not to create type definitions (`d.ts` files). We strongly recommend doing this as it fosters ecosystem library quality. Defaults to `true`\n\n## Publishing\n\nTo publish the generated package:\n\n```sh\nnpm publish\n```\n\n## Caveats\n\nAll relative file imports need to be fully specified, adhering to Node's ESM algorithm. This means that for a file like `src/lib/something/index.js`, you must include the filename with the extension:\n\n```diff\n-import { something } from './something';\n+import { something } from './something/index.js';\n```\n\nIf you are using TypeScript, you need to import `.ts` files the same way, but using a `.js` file ending, _not_ a `.ts` file ending. (This is a TypeScript design decision outside our control.) Setting `\"moduleResolution\": \"NodeNext\"` in your `tsconfig.json` or `jsconfig.json` will help you with this.\n\nAll files except Svelte files (preprocessed) and TypeScript files (transpiled to JavaScript) are copied across as-is.\n", "doc_id": "2f071c06-dd5f-4340-9a3b-6823eb1572d6", "embedding": null, "doc_hash": "5a0d806f9e777ea43bcb5589d74eac72802f258fea1f7609e1c9f9fed65ddc0f", "extra_info": null, "node_info": {"start": 10430, "end": 12343, "_node_type": "1"}, "relationships": {"1": "74e019d6-bb00-4f30-891b-54754e3f2bda", "2": "1457c5f6-1b1a-4461-b9dc-840f1fd61af3"}}, "__type__": "1"}, "eb71b480-608e-43bb-8352-3a75ce55d905": {"__data__": {"text": "---\ntitle: Netlify\n---\n\nTo deploy to Netlify, use [`adapter-netlify`](https://github.com/sveltejs/kit/tree/master/packages/adapter-netlify).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Netlify-specific options.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-netlify`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-netlify';\n\nexport default {\n\tkit: {\n\t\t// default options are shown\n\t\tadapter: adapter({\n\t\t\t// if true, will create a Netlify Edge Function rather\n\t\t\t// than using standard Node-based functions\n\t\t\tedge: false,\n\n\t\t\t// if true, will split your app into multiple functions\n\t\t\t// instead of creating a single one for the entire app.\n\t\t\t// if `edge` is true, this option cannot be used\n\t\t\tsplit: false\n\t\t})\n\t}\n};\n```\n\nThen, make sure you have a [netlify.toml](https://docs.netlify.com/configure-builds/file-based-configuration) file in the project root. This will determine where to write static assets based on the `build.publish` settings, as per this sample configuration:\n\n```toml\n[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"\n```\n\nIf the `netlify.toml` file or the `build.publish` value is missing, a default value of `\"build\"` will be used. Note that if you have set the publish directory in the Netlify UI to something else then you will need to set it in `netlify.toml` too, or use the default value of `\"build\"`.\n\n### Node version\n\nNew projects will use Node 16 by default. However, if you're upgrading a project you created a while ago it may be stuck on an older version. See [the Netlify docs](https://docs.netlify.com/configure-builds/manage-dependencies/#node-js-and-javascript) for details on manually specifying Node 16 or newer.\n\n## Netlify Edge Functions (beta)\n\nSvelteKit supports the beta release of [Netlify Edge Functions](https://docs.netlify.com/netlify-labs/experimental-features/edge-functions/). If you pass the option `edge: true` to the `adapter` function, server-side rendering will happen in a Deno-based edge function that's deployed close to the site visitor. If set to `false` (the default), the site will deploy to standard Node-based Netlify Functions.\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-netlify';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// will create a Netlify Edge Function using Deno-based\n\t\t\t// rather than using standard Node-based functions\n\t\t\tedge: true\n\t\t})\n\t}\n};\n```\n\n## Netlify alternatives to SvelteKit functionality\n\nYou may build your app using functionality provided directly by SvelteKit without relying on any Netlify functionality. Using the SvelteKit versions of these features will allow them to be used in dev mode, tested with integration tests, and to work with other adapters should you ever decide to switch away from Netlify. However, in some scenarios you may find it beneficial to use the Netlify versions of these features. One example would be if you're migrating an app that's already hosted on Netlify to SvelteKit.\n\n### Redirect rules\n\nDuring compilation, redirect rules are automatically appended to your `_redirects` file. (If", "doc_id": "eb71b480-608e-43bb-8352-3a75ce55d905", "embedding": null, "doc_hash": "f2cc8fd6e98bf25fe0dcde84769463c6ccf51bc8b6116a8edcd7d7f5ddb88b03", "extra_info": null, "node_info": {"start": 0, "end": 3272, "_node_type": "1"}, "relationships": {"1": "d4624850-71cb-4100-a7b6-6a0b1a7e0102", "3": "4d0a96b8-257c-42e3-a5ac-37aacbb72dca"}}, "__type__": "1"}, "4d0a96b8-257c-42e3-a5ac-37aacbb72dca": {"__data__": {"text": "rules are automatically appended to your `_redirects` file. (If it doesn't exist yet, it will be created.) That means:\n\n- `[[redirects]]` in `netlify.toml` will never match as `_redirects` has a [higher priority](https://docs.netlify.com/routing/redirects/#rule-processing-order). So always put your rules in the [`_redirects` file](https://docs.netlify.com/routing/redirects/#syntax-for-the-redirects-file).\n- `_redirects` shouldn't have any custom \"catch all\" rules such as `/* /foobar/:splat`. Otherwise the automatically appended rule will never be applied as Netlify is only processing [the first matching rule](https://docs.netlify.com/routing/redirects/#rule-processing-order).\n\n### Netlify Forms\n\n1. Create your Netlify HTML form as described [here](https://docs.netlify.com/forms/setup/#html-forms), e.g. as `/routes/contact/+page.svelte`. (Don't forget to add the hidden `form-name` input element!)\n2. Netlify's build bot parses your HTML files at deploy time, which means your form must be [prerendered](https://kit.svelte.dev/docs/page-options#prerender) as HTML. You can either add `export const prerender = true` to your `contact.svelte` to prerender just that page or set the `kit.prerender.force: true` option to prerender all pages.\n3. If your Netlify form has a [custom success message](https://docs.netlify.com/forms/setup/#success-messages) like `<form netlify ... action=\"/success\">` then ensure the corresponding `/routes/success/+page.svelte` exists and is prerendered.\n\n### Netlify Functions\n\nWith this adapter, SvelteKit endpoints are hosted as [Netlify Functions](https://docs.netlify.com/functions/overview/). Netlify function handlers have additional context, including [Netlify Identity](https://docs.netlify.com/visitor-access/identity/) information. You can access this context via the `event.platform.context` field inside your hooks and `+page.server` or `+layout.server` endpoints. These are [serverless functions](https://docs.netlify.com/functions/overview/) when the `edge` property is `false` in the adapter config or [edge functions](https://docs.netlify.com/edge-functions/overview/#app) when it is `true`.\n\n```js\n// @errors: 2705 7006\n/// file: +page.server.js\nexport const load = async (event) => {\n\tconst context = event.platform.context;\n\tconsole.log(context); // shows up in your functions log in the Netlify app\n};\n```\n\nAdditionally, you can add your own Netlify functions by creating a directory for them and adding the configuration to your `netlify.toml` file. For example:\n\n```toml\n[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"\n\n[functions]\n\tdirectory = \"functions\"\n```\n\n## Troubleshooting\n\n### Accessing the file system\n\nYou can't access the file system through methods like `fs.readFileSync` in Serverless/Edge environments. If you need to access files that way, do that during building the app through [prerendering](https://kit.svelte.dev/docs/page-options#prerender). If you have a blog for example and don't want to manage your content through a CMS, then you need to prerender the content (or prerender the endpoint from which you get it) and redeploy your blog everytime you add new content.", "doc_id": "4d0a96b8-257c-42e3-a5ac-37aacbb72dca", "embedding": null, "doc_hash": "9c5a21cb184b97b5ceb1aeaef60c657123b3bc524f061551c1f123e87326955a", "extra_info": null, "node_info": {"start": 3209, "end": 6366, "_node_type": "1"}, "relationships": {"1": "d4624850-71cb-4100-a7b6-6a0b1a7e0102", "2": "eb71b480-608e-43bb-8352-3a75ce55d905"}}, "__type__": "1"}, "4746ec2f-d6a6-4308-9a85-c66baa59585e": {"__data__": {"text": "---\ntitle: Vercel\n---\n\nTo deploy to Vercel, use [`adapter-vercel`](https://github.com/sveltejs/kit/tree/master/packages/adapter-vercel).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Vercel-specific options.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-vercel`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307 2345\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-vercel';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// see the 'Deployment configuration' section below\n\t\t})\n\t}\n};\n```\n\n## Deployment configuration\n\nTo control how your routes are deployed to Vercel as functions, you can specify deployment configuration, either through the option shown above or with [`export const config`](page-options#config) inside `+server.js`, `+page(.server).js` and `+layout(.server).js` files.\n\nFor example you could deploy some parts of your app as [Edge Functions](https://vercel.com/docs/concepts/functions/edge-functions)...\n\n```js\n/// file: about/+page.js\n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\truntime: 'edge'\n};\n```\n\n...and others as [Serverless Functions](https://vercel.com/docs/concepts/functions/serverless-functions) (note that by specifying `config` inside a layout, it applies to all child pages):\n\n```js\n/// file: admin/+layout.js\n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\truntime: 'nodejs18.x'\n};\n```\n\nThe following options apply to all functions:\n\n- `runtime`: `'edge'`, `'nodejs16.x'` or `'nodejs18.x'`. By default, the adapter will select `'nodejs16.x'` or `'nodejs18.x'` depending on the Node version your project is configured to use on the Vercel dashboard\n- `regions`: an array of [edge network regions](https://vercel.com/docs/concepts/edge-network/regions) (defaulting to `[\"iad1\"]` for serverless functions) or `'all'` if `runtime` is `edge` (its default). Note that multiple regions for serverless functions are only supported on Enterprise plans\n- `split`: if `true`, causes a route to be deployed as an individual function. If `split` is set to `true` at the adapter level, all routes will be deployed as individual functions\n\nAdditionally, the following option applies to edge functions:\n- `external`: an array of dependencies that esbuild should treat as external when bundling functions. This should only be used to exclude optional dependencies that will not run outside Node\n\nAnd the following option apply to serverless functions:\n- `memory`: the amount of memory available to the function. Defaults to `1024` Mb, and can be decreased to `128` Mb or [increased](https://vercel.com/docs/concepts/limits/overview#serverless-function-memory) in 64Mb increments up to `3008` Mb on Pro or Enterprise accounts\n- `maxDuration`: maximum execution duration of the function. Defaults to `10` seconds for Hobby accounts, `60` for Pro and `900` for Enterprise\n- `isr`: configuration Incremental Static Regeneration, described below\n\nIf your functions need to access data in a specific region, it's recommended that they be deployed in the same region (or close to it) for optimal performance.\n\n## Incremental Static Regeneration\n\nVercel supports [Incremental Static", "doc_id": "4746ec2f-d6a6-4308-9a85-c66baa59585e", "embedding": null, "doc_hash": "18b68cbffe287b6a949c96acbb5d3f5a339efde6b4161b20c835a32cda39bc23", "extra_info": null, "node_info": {"start": 0, "end": 3311, "_node_type": "1"}, "relationships": {"1": "bd988c65-60df-4660-aa6f-e02c3cecee37", "3": "4bd63418-5e11-4071-b78b-44617421b1d3"}}, "__type__": "1"}, "4bd63418-5e11-4071-b78b-44617421b1d3": {"__data__": {"text": "Incremental Static Regeneration\n\nVercel supports [Incremental Static Regeneration](https://vercel.com/docs/concepts/incremental-static-regeneration/overview) (ISR), which provides the performance and cost advantages of prerendered content with the flexibility of dynamically rendered content.\n\nTo add ISR to a route, include the `isr` property in your `config` object:\n\n```js\n/// file: blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$env/static/private' {\n\texport const BYPASS_TOKEN: string;\n}\n\n// @filename: index.js\n// ---cut---\nimport { BYPASS_TOKEN } from '$env/static/private';\n\nexport const config = {\n\tisr: {\n\t\t// Expiration time (in seconds) before the cached asset will be re-generated by invoking the Serverless Function.\n\t\t// Setting the value to `false` means it will never expire.\n\t\texpiration: 60,\n\n\t\t// Random token that can be provided in the URL to bypass the cached version of the asset, by requesting the asset\n\t\t// with a __prerender_bypass=<token> cookie.\n\t\t//\n\t\t// Making a `GET` or `HEAD` request with `x-prerender-revalidate: <token>` will force the asset to be re-validated.\n\t\tbypassToken: BYPASS_TOKEN,\n\n\t\t// List of valid query parameters. Other parameters (such as utm tracking codes) will be ignored,\n\t\t// ensuring that they do not result in content being regenerated unnecessarily\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\nThe `expiration` property is required; all others are optional.\n\n## Environment variables\n\nVercel makes a set of [deployment-specific environment variables](https://vercel.com/docs/concepts/projects/environment-variables#system-environment-variables) available. Like other environment variables, these are accessible from `$env/static/private` and `$env/dynamic/private` (sometimes \u2014 more on that later), and inaccessible from their public counterparts. To access one of these variables from the client:\n\n```js\n// @errors: 2305\n/// file: +layout.server.js\nimport { VERCEL_COMMIT_REF } from '$env/static/private';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load() {\n\treturn {\n\t\tdeploymentGitBranch: VERCEL_COMMIT_REF\n\t};\n}\n```\n\n```svelte\n/// file: +layout.svelte\n<script>\n\t/** @type {import('./$types').LayoutServerData} */\n\texport let data;\n</script>\n\n<p>This staging environment was deployed from {data.deploymentGitBranch}.</p>\n```\n\nSince all of these variables are unchanged between build time and run time when building on Vercel, we recommend using `$env/static/private` \u2014 which will statically replace the variables, enabling optimisations like dead code elimination \u2014 rather than `$env/dynamic/private`.\n\n## Notes\n\n### Vercel functions\n\nIf you have Vercel functions contained in the `api` directory at the project's root, any requests for `/api/*` will _not_ be handled by SvelteKit. You should implement these as [API routes](https://kit.svelte.dev/docs/routing#server) in your SvelteKit app instead, unless you need to use a non-JavaScript language in which case you will need to ensure that you don't have any `/api/*` routes in your SvelteKit app.\n\n### Node version\n\nProjects created before a certain date will default to using Node 14, while SvelteKit requires Node 16 or later. You can [change the Node version in your project settings](https://vercel.com/docs/concepts/functions/serverless-functions/runtimes/node-js#node.js-version).\n\n## Troubleshooting\n\n### Accessing the file", "doc_id": "4bd63418-5e11-4071-b78b-44617421b1d3", "embedding": null, "doc_hash": "4a3253d5dcfe2261dd589727ab5ac08f425b0dc1c9a8132313f841edf0698ca8", "extra_info": null, "node_info": {"start": 3249, "end": 6637, "_node_type": "1"}, "relationships": {"1": "bd988c65-60df-4660-aa6f-e02c3cecee37", "2": "4746ec2f-d6a6-4308-9a85-c66baa59585e", "3": "e6a3c1ed-ec02-4970-a4a2-0c33a15be447"}}, "__type__": "1"}, "e6a3c1ed-ec02-4970-a4a2-0c33a15be447": {"__data__": {"text": "Troubleshooting\n\n### Accessing the file system\n\nYou can't access the file system through methods like `fs.readFileSync` in Serverless/Edge environments. If you need to access files that way, do that during building the app through [prerendering](https://kit.svelte.dev/docs/page-options#prerender). If you have a blog for example and don't want to manage your content through a CMS, then you need to prerender the content (or prerender the endpoint from which you get it) and redeploy your blog everytime you add new content.\n", "doc_id": "e6a3c1ed-ec02-4970-a4a2-0c33a15be447", "embedding": null, "doc_hash": "d86683dbb11ef8223d41144bfad3e178f2878010f13a756bef30c18fdea62e13", "extra_info": null, "node_info": {"start": 6661, "end": 7187, "_node_type": "1"}, "relationships": {"1": "bd988c65-60df-4660-aa6f-e02c3cecee37", "2": "4bd63418-5e11-4071-b78b-44617421b1d3"}}, "__type__": "1"}, "3ea9a0d4-38d6-4581-8f95-689943d3f699": {"__data__": {"text": "---\ntitle: Writing adapters\n---\n\nIf an adapter for your preferred environment doesn't yet exist, you can build your own. We recommend [looking at the source for an adapter](https://github.com/sveltejs/kit/tree/master/packages) to a platform similar to yours and copying it as a starting point.\n\nAdapters packages must implement the following API, which creates an `Adapter`:\n\n```js\n// @filename: ambient.d.ts\ntype AdapterSpecificOptions = any;\n\n// @filename: index.js\n// ---cut---\n/** @param {AdapterSpecificOptions} options */\nexport default function (options) {\n\t/** @type {import('@sveltejs/kit').Adapter} */\n\tconst adapter = {\n\t\tname: 'adapter-package-name',\n\t\tasync adapt(builder) {\n\t\t\t// adapter implementation\n\t\t}\n\t};\n\n\treturn adapter;\n}\n```\n\nThe types for `Adapter` and its parameters are available in [types/index.d.ts](https://github.com/sveltejs/kit/blob/master/packages/kit/types/index.d.ts).\n\nWithin the `adapt` method, there are a number of things that an adapter should do:\n\n- Clear out the build directory\n- Write SvelteKit output with `builder.writeClient`, `builder.writeServer`, and `builder.writePrerendered`\n- Output code that:\n\t- Imports `Server` from `${builder.getServerDirectory()}/index.js`\n\t- Instantiates the app with a manifest generated with `builder.generateManifest({ relativePath })`\n\t- Listens for requests from the platform, converts them to a standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) if necessary, calls the `server.respond(request, { getClientAddress })` function to generate a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) and responds with it\n\t- expose any platform-specific information to SvelteKit via the `platform` option passed to `server.respond`\n\t- Globally shims `fetch` to work on the target platform, if necessary. SvelteKit provides a `@sveltejs/kit/install-fetch` helper for platforms that can use `node-fetch`\n- Bundle the output to avoid needing to install dependencies on the target platform, if necessary\n- Put the user's static files and the generated JS/CSS in the correct location for the target platform\n\nWhere possible, we recommend putting the adapter output under the `build/` directory with any intermediate output placed under `.svelte-kit/[adapter-name]`.\n", "doc_id": "3ea9a0d4-38d6-4581-8f95-689943d3f699", "embedding": null, "doc_hash": "caeec629b22b35d418e72d9d345ebdeca1765a335c69921d110a66626fbda517", "extra_info": null, "node_info": {"start": 0, "end": 2281, "_node_type": "1"}, "relationships": {"1": "6bc81f69-656f-4931-bf81-e1fc9d0c0b50"}}, "__type__": "1"}}}